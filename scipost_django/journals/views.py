__copyright__ = "Copyright Â© Stichting SciPost (SciPost Foundation)"
__license__ = "AGPL v3"


from datetime import timedelta
import hashlib
import json
import os

import random
import string
import shutil
from typing import Any, Dict
import requests

import matplotlib

from mails.utils import DirectMailUtil
from ethics.forms import GenAIDisclosureForm
from ethics.models import GenAIDisclosure
from scipost.permissions import HTMXPermissionsDenied, HTMXResponse
from proceedings.models import Proceedings
from profiles.models import Profile
from submissions.models.decision import EditorialDecision

matplotlib.use("Agg")
import matplotlib.pyplot as plt
import io, base64

from django.contrib.auth.decorators import login_required
from django.contrib.contenttypes.models import ContentType
from django.core.exceptions import PermissionDenied
from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
from django.urls import reverse, reverse_lazy
from django.conf import settings
from django.contrib import messages
from django.db import transaction
from django.db.models import (
    Q,
    Count,
    Exists,
    OuterRef,
    Prefetch,
    QuerySet,
    Subquery,
    prefetch_related_objects,
)
from django.http import Http404, HttpRequest, HttpResponse
from django.template.response import TemplateResponse
from django.utils import timezone
from django.utils.decorators import method_decorator
from django.utils.html import format_html
from django.views.generic.detail import DetailView
from django.views.generic.edit import CreateView, UpdateView
from django.views.generic.list import ListView
from django.shortcuts import get_object_or_404, get_list_or_404, render, redirect

from dal import autocomplete

from .constants import (
    PUBLICATION_PUBLISHED,
    STATUS_DRAFT,
    ISSUES_AND_VOLUMES,
    ISSUES_ONLY,
    INDIVIDUAL_PUBLICATIONS,
)
from .exceptions import InvalidDOIError
from .models import (
    Journal,
    Volume,
    Issue,
    Publication,
    Deposit,
    DOAJDeposit,
    GenericDOIDeposit,
    PublicationAuthorsTable,
    PublicationUpdate,
    AutogeneratedFileContentTemplate,
    PublicationResource,
)
from .forms import (
    AbstractJATSForm,
    CitationListItemForm,
    CreateProceedingsMetadataXMLForm,
    CreatePublicationMetadataXMLForm,
    DraftPublicationUpdateForm,
    FundingInfoForm,
    HTMXInlinePublicationResourceForm,
    VolumeForm,
    IssueForm,
    AuthorsTableOrganizationSelectForm,
    CreateMetadataXMLForm,
    CitationListBibitemsForm,
    ReferenceFormSet,
    CreatePublicationMetadataDOAJForm,
    DraftPublicationForm,
    PublicationGrantsForm,
    DraftAccompanyingPublicationForm,
    DraftPublicationApprovalForm,
    PublicationPublishForm,
    PublicationAuthorOrderingFormSet,
    PubFracsFormSet,
    PublicationDynSelForm,
)
from .mixins import PublicationMixin, ProdSupervisorPublicationPermissionMixin
from .services import update_citedby

from comments.models import Comment
from common.utils import get_current_domain
from common.views import HTMXInlineCRUDModelFormView, HTMXInlineCRUDModelListView
from finances.models import PubFrac
from funders.forms import FunderSelectForm, GrantSelectForm
from funders.models import Grant, Funder
from mails.views import MailEditorSubview
from ontology.models import AcademicField, Topic
from ontology.forms import SelectTopicForm
from organizations.models import Organization
from profiles.forms import ProfileSelectForm
from submissions.models import Submission, Report
from scipost.forms import ConfirmationForm
from scipost.models import Contributor
from scipost.mixins import PermissionsMixin, RequestViewMixin, PaginationMixin

from guardian.decorators import permission_required


################
# Autocomplete #
################


class PublicationAutocompleteView(autocomplete.Select2QuerySetView):
    """
    View to feed the Select2 widget.
    """

    def get_queryset(self):
        qs = Publication.objects.published()
        if self.q:
            qs = qs.filter(
                Q(title__icontains=self.q)
                | Q(doi_label__icontains=self.q)
                | Q(author_list__icontains=self.q)
            )
        return qs.order_by("-publication_date")

    def get_result_label(self, item):
        return format_html(
            '<strong>{}</strong><br>{}<br><span class="text-muted">by {}</span>',
            item.doi_label,
            item.title,
            item.author_list,
        )


class OwnPublicationAutocompleteView(PublicationAutocompleteView):
    """
    View to feed the Select2 widget, specialized to user's own publications.
    """

    def get_queryset(self):
        qs = self.request.user.contributor.profile.publications()
        if self.q:
            qs = qs.filter(
                Q(title__icontains=self.q)
                | Q(doi_label__icontains=self.q)
                | Q(author_list__icontains=self.q)
            )
        return qs.order_by("-publication_date")


def _hx_publication_dynsel_list(request):
    form = PublicationDynSelForm(request.POST or None)
    if form.is_valid():
        publications = form.search_results()
    else:
        publications = Publication.objects.none()
    context = {
        "publications": publications,
        "action_url_name": form.cleaned_data["action_url_name"],
        "action_url_base_kwargs": form.cleaned_data["action_url_base_kwargs"],
        "action_target_element_id": form.cleaned_data["action_target_element_id"],
    }
    return render(request, "journals/_hx_publication_dynsel_list.html", context)


################
# DOI dispatch #
################


def doi_dispatch(
    request, journal_tag, part_1=None, part_2=None, part_3=None, suffix=None
):
    """
    Dispatch given DOI route to the appropriate view according to the Journal's settings.

    journal_tag -- Part of the DOI right before the first period.

    * part_1 (optional) -- Part of the DOI after the first period.
    * part_2 (optional) -- Part of the DOI after the second period.
    * part_3 (optional) -- Part of the DOI after the third period.
    * suffix (optional) -- Suffix of form r[number[.number]].
    """
    journal = get_object_or_404(Journal, doi_label=journal_tag)
    doi_label = ".".join(
        [s for s in [journal_tag, part_1, part_2, part_3] if s is not None]
    ) + (f"-{suffix}" if suffix else "")

    match (part_1, part_2, part_3, suffix):
        case (None, None, None, None):
            # This DOI refers to a Journal landing page.
            return journal_detail(request, doi_label)

        case (part_1, None, None, None):
            if journal.structure == INDIVIDUAL_PUBLICATIONS:
                return publication_detail(request, doi_label)
            elif journal.structure == ISSUES_ONLY:
                return issue_detail(request, doi_label)
            else:
                # The third option: a `Issue and Volume Journal DOI` would lead to a "volume detail page",
                # but that does not exist. Redirect to the Journal landing page instead.
                return journal_detail(request, journal_tag)

        case (part_1, part_2, None, None):
            if journal.structure == ISSUES_AND_VOLUMES:
                return issue_detail(request, doi_label)
            elif journal.structure == ISSUES_ONLY:
                return publication_detail(request, doi_label)

        case (part_1, part_2, part_3, None):
            return publication_detail(request, doi_label)

        case (part_1, part_2, part_3, suffix):
            return publication_detail(request, doi_label)

        case _:
            raise InvalidDOIError(
                {
                    "journal_tag": journal_tag,
                    "part_1": part_1,
                    "part_2": part_2,
                    "part_3": part_3,
                }
            )


############
# Journals
############


class JournalListView(ListView):
    model = Journal

    def get_queryset(self):
        qs = super().get_queryset()
        # for url /journals/?field=[acad_field_slug]
        if self.request.GET.get("field"):
            qs = qs.filter(college__acad_field__slug=self.request.GET.get("field"))
        # for url /journals/[acad_field_slug]
        if "acad_field" in self.kwargs:
            qs = qs.filter(college__acad_field=self.kwargs["acad_field"])
        return qs

    def get_context_data(self, *args, **kwargs):
        context = super().get_context_data(*args, **kwargs)
        # for url /journals/?field=[acad_field_slug]
        if self.request.GET.get("field"):
            context["acad_field"] = get_object_or_404(
                AcademicField, slug=self.request.GET.get("field")
            )
        # for url /journals/[acad_field_slug]
        if "acad_field" in self.kwargs:
            context["acad_field"] = self.kwargs["acad_field"]
        return context


class PublicationListView(PaginationMixin, ListView):
    """
    Show Publications filtered per specialty.
    """

    queryset = Publication.objects.published()
    paginate_by = 10

    def get_queryset(self):
        qs = super().get_queryset()
        if self.request.GET.get("journal"):
            qs = qs.for_journal(self.request.GET["journal"])

        if self.request.GET.get("issue"):
            try:
                issue = int(self.request.GET["issue"])
            except ValueError:
                issue = None
            if issue:
                qs = qs.filter(in_issue__id=issue)
        if self.request.GET.get("specialty"):
            qs = qs.for_specialty(self.request.GET["specialty"])

        if self.request.GET.get("orderby") == "citations":
            qs = qs.order_by("-number_of_citations")
        else:
            qs = qs.order_by("-publication_date", "-paper_nr")
        return qs

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        return context


def journal_detail(request, doi_label):
    """Journal details page.

    The landing page of a Journal lists either the latest and the current issue of a Journal
    or paginates its individual Publications.
    """
    journal = get_object_or_404(Journal, doi_label=doi_label)
    # Guard against inactive journals
    if not (journal.active or request.user.is_staff):
        raise PermissionDenied("Journal is not active")

    prefetch_related_objects([journal], "contained_series")

    accepted_submissions = (
        (
            Submission.objects.accepted()
            .annotate(
                decision_journal=Subquery(
                    EditorialDecision.objects.filter(submission=OuterRef("pk"))
                    .nondeprecated()
                    .order_by("-version")
                    .values("for_journal")[:1]
                )
            )
            .filter(decision_journal=journal)
        )
        .annotate(
            thread_sequence_order=Subquery(
                Submission.objects.filter(
                    thread_hash=OuterRef("thread_hash"),
                    submission_date__lte=OuterRef("submission_date"),
                )
                .annotate(nr_submissions=Count("pk"))
                .values("nr_submissions")[:1]
            ),
            is_latest=~Exists(
                Submission.objects.filter(
                    thread_hash=OuterRef("thread_hash"),
                    submission_date__gt=OuterRef("submission_date"),
                )
            ),
        )
        .prefetch_related(
            "specialties",
        )
        .select_related(
            "acad_field",
            "preprint",
            "submitted_to",
        )
    )

    journal_publications = Publication.objects.for_journal(journal.name).published()

    most_cited = journal_publications.most_cited(5)
    latest_publications = journal_publications[:5]

    context = {
        "journal": journal,
        "most_cited": most_cited,
        "latest_publications": latest_publications,
        "accepted_submissions": accepted_submissions,
    }
    return render(request, "journals/journal_detail.html", context)


class VolumesAdminListView(PermissionsMixin, PaginationMixin, ListView):
    """
    Admin: List all Volumes in the database.
    """

    model = Volume
    permission_required = "scipost.can_manage_issues"
    paginate_by = 20


class VolumesAdminAddView(PermissionsMixin, CreateView):
    """
    Admin: Create new Volume.
    """

    model = Volume
    form_class = VolumeForm
    success_url = reverse_lazy("journals:admin_volumes_list")
    permission_required = "scipost.can_manage_issues"


class VolumesAdminUpdateView(PermissionsMixin, UpdateView):
    """
    Admin: Update Volume instance.
    """

    model = Volume
    form_class = VolumeForm
    slug_field = slug_url_kwarg = "doi_label"
    success_url = reverse_lazy("journals:admin_volumes_list")
    permission_required = "scipost.can_manage_issues"


class IssuesView(DetailView):
    """
    List all Issues sorted per Journal.
    """

    queryset = Journal.objects.active().has_issues()
    slug_field = slug_url_kwarg = "doi_label"
    template_name = "journals/journal_issues.html"


class IssuesAdminListView(PermissionsMixin, PaginationMixin, ListView):
    """
    Admin: List all Issues in the database.
    """

    model = Issue
    permission_required = "scipost.can_manage_issues"
    paginate_by = 20


class IssuesAdminAddView(PermissionsMixin, CreateView):
    """
    Admin: Create new Issue.
    """

    model = Issue
    form_class = IssueForm
    success_url = reverse_lazy("journals:admin_issue_list")
    permission_required = "scipost.can_manage_issues"


class IssuesAdminUpdateView(PermissionsMixin, UpdateView):
    """
    Admin: Update issue instance.
    """

    model = Issue
    form_class = IssueForm
    slug_field = slug_url_kwarg = "doi_label"
    success_url = reverse_lazy("journals:admin_issue_list")
    permission_required = "scipost.can_manage_issues"


def authoring(request, doi_label=None):
    """Author information for a given Journal, or in general if no doi_label in given."""
    context = {}
    if doi_label:
        journal = get_object_or_404(Journal, doi_label=doi_label)
        # Guard against inactive journals
        if not (journal.active or request.user.is_staff):
            raise PermissionDenied("Journal is not active")

        context = {"journal": journal}
    return render(request, "journals/authoring.html", context)


def refereeing(request, doi_label=None):
    """Author information for a given Journal, or in general if no doi_label in given."""
    context = {}
    if doi_label:
        journal = get_object_or_404(Journal, doi_label=doi_label)
        # Guard against inactive journals
        if not (journal.active or request.user.is_staff):
            raise PermissionDenied("Journal is not active")

        context = {"journal": journal}
    return render(request, "journals/refereeing.html", context)


def redirect_to_about(request, doi_label):
    journal = get_object_or_404(Journal, doi_label=doi_label)
    # Guard against inactive journals
    if not (journal.active or request.user.is_staff):
        raise PermissionDenied("Journal is not active")
    return redirect(
        reverse("journal:about", kwargs={"doi_label": journal.doi_label}),
        permanent=True,
    )


def about(request, doi_label):
    """Journal specific about page."""
    journal = get_object_or_404(Journal, doi_label=doi_label)
    # Guard against inactive journals
    if not (journal.active or request.user.is_staff):
        raise PermissionDenied("Journal is not active")

    year = timezone.now().year
    journal_publications = journal.get_publications()

    nr_publications = journal_publications.filter(publication_date__year=year).count()
    nr_publications_1 = journal_publications.filter(
        publication_date__year=year - 1
    ).count()
    nr_publications_2 = journal_publications.filter(
        publication_date__year=year - 2
    ).count()

    nr_citations_per_year = journal_publications.citations_per_year()
    nr_citations = nr_citations_per_year.get(year, 0)
    nr_citations_1 = nr_citations_per_year.get(year - 1, 0)
    nr_citations_2 = nr_citations_per_year.get(year - 2, 0)

    citedby_citescore = journal_publications.citescore(year=year)
    citedby_citescore_1 = journal_publications.citescore(year=year - 1)
    citedby_citescore_2 = journal_publications.citescore(year=year - 2)

    citedby_impact_factor_1 = journal_publications.impact_factor(year - 1)
    citedby_impact_factor_2 = journal_publications.impact_factor(year - 2)

    context = {
        "journal": journal,
        "nr_publications": nr_publications,
        "nr_publications_1": nr_publications_1,
        "nr_publications_2": nr_publications_2,
        "nr_citations": nr_citations,
        "nr_citations_1": nr_citations_1,
        "nr_citations_2": nr_citations_2,
        "citedby_citescore": citedby_citescore,
        "citedby_citescore_1": citedby_citescore_1,
        "citedby_citescore_2": citedby_citescore_2,
        "citedby_impact_factor_1": citedby_impact_factor_1,
        "citedby_impact_factor_2": citedby_impact_factor_2,
    }
    return render(request, "journals/about.html", context)


def provide_plot(x, y, name, nonce=None):
    fig, ax = plt.subplots(figsize=(5, 3))
    ax.bar(x, y)
    ax.set_title(name)

    plot_svg = io.StringIO()
    fig.savefig(plot_svg, format="svg")
    plot_svg = plot_svg.getvalue()
    # Manipulate the SVG to make it display properly in the browser
    # Add the classes `w-100` and `h-100` to make the SVG responsive
    plot_svg = plot_svg.replace("<svg ", '<svg class="w-100 h-auto" ')
    return plot_svg


def metrics(request, doi_label, specialty=None):
    journal = get_object_or_404(Journal, doi_label=doi_label)
    # Guard against inactive journals
    if not (journal.active or request.user.is_staff):
        raise PermissionDenied("Journal is not active")
    context = {
        "journal": journal,
        "specialty": specialty,
    }
    key = "all"
    if specialty:
        key = specialty.slug
    nr_publications_plot = provide_plot(
        x=journal.cf_metrics["nr_publications"]["years"],
        y=journal.cf_metrics["nr_publications"]["nr_publications"][key],
        name="Publications",
        nonce=request.csp_nonce,
    )
    nr_submissions_plot = provide_plot(
        x=journal.cf_metrics["nr_submissions"]["years"],
        y=journal.cf_metrics["nr_submissions"]["nr_submissions"][key],
        name="Submissions",
        nonce=request.csp_nonce,
    )
    nr_citations_plot = provide_plot(
        x=journal.cf_metrics["nr_citations"]["years"],
        y=journal.cf_metrics["nr_citations"]["nr_citations"][key],
        name="Total Citations",
        nonce=request.csp_nonce,
    )
    citescore_plot = provide_plot(
        x=journal.cf_metrics["citedby_citescore"]["years"],
        y=journal.cf_metrics["citedby_citescore"]["citedby_citescore"][key],
        name="Citescore",
        nonce=request.csp_nonce,
    )
    impact_factor_plot = provide_plot(
        x=journal.cf_metrics["citedby_impact_factor"]["years"],
        y=journal.cf_metrics["citedby_impact_factor"]["citedby_impact_factor"][key],
        name="Impact Factor",
        nonce=request.csp_nonce,
    )
    context["nr_publications_plot"] = nr_publications_plot
    context["nr_submissions_plot"] = nr_submissions_plot
    context["nr_citations_plot"] = nr_citations_plot
    context["citescore_plot"] = citescore_plot
    context["impact_factor_plot"] = impact_factor_plot
    return render(request, "journals/metrics.html", context)


def issue_detail(request, doi_label):
    """Issue detail page."""
    issue = get_object_or_404(Issue.objects.open_or_published(), doi_label=doi_label)
    journal = issue.in_journal or issue.in_volume.in_journal

    papers = issue.publications.published().order_by("paper_nr")
    next_issue = (
        Issue.objects.published()
        .filter(start_date__gt=issue.start_date)
        .filter(
            Q(in_volume__in_journal=journal) | Q(in_journal=journal),
        )
        .distinct()
        .order_by("start_date")
        .first()
    )
    prev_issue = (
        Issue.objects.published()
        .filter(start_date__lt=issue.start_date)
        .filter(Q(in_volume__in_journal=journal) | Q(in_journal=journal))
        .distinct()
        .order_by("start_date")
        .last()
    )

    context = {
        "issue": issue,
        "prev_issue": prev_issue,
        "next_issue": next_issue,
        "papers": papers,
        "journal": journal,
    }
    return render(request, "journals/journal_issue_detail.html", context)


#######################
# Publication process #
#######################
class PublicationGrantsView(PermissionsMixin, UpdateView):
    """Add/update grants associated to a Publication."""

    permission_required = "scipost.can_draft_publication"
    queryset = Publication.objects.drafts()
    slug_field = slug_url_kwarg = "doi_label"
    form_class = PublicationGrantsForm
    template_name = "journals/grants_form.html"


class PublicationGrantsRemovalView(PermissionsMixin, DetailView):
    """
    Remove grant associated to a Publication.
    """

    permission_required = "scipost.can_draft_publication"
    queryset = Publication.objects.drafts()
    slug_field = slug_url_kwarg = "doi_label"

    def get(self, request, *args, **kwargs):
        super().get(request, *args, **kwargs)
        grant = get_object_or_404(Grant, id=kwargs.get("grant_id"))
        self.object.grants.remove(grant)
        return redirect(
            reverse("journals:update_grants", args=(self.object.doi_label,))
        )


class DraftPublicationCreateView(PermissionsMixin, CreateView):
    """
    Create a draft of a Publication.
    """

    permission_required = "scipost.can_draft_publication"
    model = Publication
    form_class = DraftPublicationForm
    template_name = "journals/publication_form.html"

    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        kwargs["identifier_w_vn_nr"] = self.kwargs.get("identifier_w_vn_nr")
        kwargs["issue_id"] = self.request.GET.get("issue")
        return kwargs

    def post(self, request: HttpRequest, *args: str, **kwargs: Any) -> HttpResponse:
        form = self.get_form()
        gen_ai_form = self.get_gen_ai_disclosure_form(
            form.submission, request.POST or None
        )

        # Override superclass `post` to check for disclosure form validity
        if form.is_valid() and (gen_ai_form.is_valid() if gen_ai_form else True):
            return self.form_valid(form, gen_ai_form)
        else:
            return self.form_invalid(form)

    def get_gen_ai_disclosure_form(
        self, submission: Submission, data=None
    ) -> GenAIDisclosureForm | None:
        """
        Returns the GenAI disclosure form for the current request.
        If a submission disclosure exists, it initializes the form with its data.
        """
        self.submission_disclosure = submission.gen_ai_disclosures.first()
        if self.submission_disclosure:
            return GenAIDisclosureForm(
                data,
                initial={
                    "was_used": self.submission_disclosure.was_used,
                    "use_details": self.submission_disclosure.use_details,
                }
                if self.submission_disclosure
                else None,
            )

    def get_context_data(self, **kwargs: Any) -> Dict[str, Any]:
        context = super().get_context_data(**kwargs)
        if (form := context.get("form")) and (submission := form.submission):
            context["gen_ai_disclosure_form"] = self.get_gen_ai_disclosure_form(
                submission
            )
        return context

    def form_valid(self, form, gen_ai_form):
        """
        Override form_valid to set the author associations and copy the GenAI disclosure.
        """
        super_form_valid = super().form_valid(form)
        if gen_ai_form and self.object and self.submission_disclosure:
            gen_ai_form.save(
                contributor=self.submission_disclosure.contributor,
                for_object=self.object,
            )

        return super_form_valid


class DraftPublicationUpdateView(PermissionsMixin, UpdateView):
    """
    Any Production Officer or Administrator can draft a new publication without publishing here.
    The actual publishing is done at a later stage, after the draft has been finished.
    """

    permission_required = "scipost.can_draft_publication"
    queryset = Publication.objects.unpublished()
    slug_url_kwarg = "doi_label"
    slug_field = "doi_label"
    form_class = DraftPublicationForm
    template_name = "journals/publication_form.html"

    def get_object(self, queryset=None):
        publication = Publication.objects.get(doi_label=self.kwargs.get("doi_label"))
        if publication.status == STATUS_DRAFT:
            return publication
        if self.request.user.has_perm("scipost.can_publish_accepted_submission"):
            return publication
        raise Http404("Found Publication is not in draft")

    def post(self, request: HttpRequest, *args: str, **kwargs: Any) -> HttpResponse:
        self.object = self.get_object()
        form = self.get_form()
        gen_ai_form = self.get_gen_ai_disclosure_form(self.object, request.POST or None)

        # Override superclass `post` to check for disclosure form validity
        if form.is_valid() and (gen_ai_form.is_valid() if gen_ai_form else True):
            return self.form_valid(form, gen_ai_form)
        else:
            return self.form_invalid(form)

    def get(self, request: HttpRequest, *args: str, **kwargs: Any) -> HttpResponse:
        self.object = self.get_object()
        return super().get(request, *args, **kwargs)

    def get_context_data(self, **kwargs: Any) -> Dict[str, Any]:
        context = super().get_context_data(**kwargs)
        context["gen_ai_disclosure_form"] = self.get_gen_ai_disclosure_form(self.object)
        return context

    def get_gen_ai_disclosure_form(
        self, publication, data=None
    ) -> GenAIDisclosureForm | None:
        disclosure = GenAIDisclosure.objects.filter(publication=publication).first()
        if disclosure:
            return GenAIDisclosureForm(
                data,
                instance=GenAIDisclosure.objects.filter(
                    publication=publication
                ).first(),
            )

    def form_valid(self, form, gen_ai_form):
        super_form_valid = super().form_valid(form)
        if gen_ai_form:
            gen_ai_form.save()
        return super_form_valid

    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        kwargs["identifier_w_vn_nr"] = self.kwargs.get("identifier_w_vn_nr")
        kwargs["issue_id"] = self.request.GET.get("issue")
        return kwargs


@permission_required("scipost.can_publish_accepted_submission", raise_exception=True)
def view_autogenerated_file(request, doi_label, autotemplate_id):
    publication = get_object_or_404(Publication, doi_label=doi_label)
    autotemplate = get_object_or_404(
        AutogeneratedFileContentTemplate, pk=autotemplate_id
    )
    file_contents = string.Template(autotemplate.content_template_string).substitute(
        title=publication.title,
        author_list=publication.author_list,
        doi_string=publication.doi_string,
        absolute_url=f"https://{request.get_host()}{publication.get_absolute_url()}",
        citation=publication.citation,
        publication_date=publication.publication_date.strftime("%Y-%m-%d"),
        license=publication.cc_license,
        resources=publication.resources_as_md(),
    )
    context = {
        "publication": publication,
        "autotemplate": autotemplate,
        "file_contents": file_contents,
    }
    return render(request, "journals/publication_view_autogenerated_file.html", context)


@permission_required("scipost.can_draft_publication", raise_exception=True)
def draft_publication_update(request, doi_label):
    publication = get_object_or_404(Publication, doi_label=doi_label)
    if request.method == "POST":
        form = DraftPublicationUpdateForm(request.POST, publication=publication)
        if form.is_valid():
            update = form.save()
            return redirect(update.get_absolute_url())
    else:
        form = DraftPublicationUpdateForm(publication=publication)
    context = {
        "publication": publication,
        "form": form,
    }
    return render(request, "journals/draft_publication_update.html", context)


@permission_required("scipost.can_draft_publication", raise_exception=True)
def draft_accompanying_publication(request, doi_label):
    anchor = get_object_or_404(Publication, doi_label=doi_label)
    if request.method == "POST":
        form = DraftAccompanyingPublicationForm(request.POST)
        if form.is_valid():
            companion = form.save()
            return redirect(companion.get_absolute_url())
    else:
        form = DraftAccompanyingPublicationForm(
            initial={
                "anchor": anchor,
                "title": anchor.title,
                "abstract": anchor.abstract,
            }
        )
    context = {
        "anchor": anchor,
        "form": form,
    }
    return render(request, "journals/draft_accompanying_publication.html", context)


@permission_required("scipost.can_draft_publication", raise_exception=True)
def manage_publication_resources(request, doi_label):
    publication = get_object_or_404(Publication, doi_label=doi_label)

    # Determine whether to display button with automatic creation of resource
    # Currently, only possible for ChemaRxiv submissions
    can_fetch_resources = (
        "chemrxiv"
        in publication.accepted_submission.preprint.identifier_w_vn_nr.lower()
    )

    context = {
        "publication": publication,
        "can_fetch_resources": can_fetch_resources,
    }
    return TemplateResponse(
        request, "journals/manage_publication_resources.html", context
    )


def fetch_publication_resources(request, doi_label):
    publication = get_object_or_404(Publication, doi_label=doi_label)
    if (
        "chemrxiv"
        not in publication.accepted_submission.preprint.identifier_w_vn_nr.lower()
    ):
        messages.error(
            request, "Resource fetching is only available for ChemRxiv submissions"
        )
        return redirect(
            reverse("journals:manage_publication_resources", args=(doi_label,))
        )

    # Fetch resources from ChemRxiv
    response = requests.get(
        f"https://chemrxiv.org/engage/chemrxiv/public-api/v1/items/doi/"
        + publication.accepted_submission.preprint.identifier_w_vn_nr
    )

    if response.status_code != 200:
        messages.error(request, "Resource fetching failed.")
        return redirect(
            reverse("journals:manage_publication_resources", args=(doi_label,))
        )

    if resources := response.json().get("suppItems", []):
        resources = sorted(resources, key=lambda x: x.get("id"))

    for resource in resources:
        PublicationResource.objects.get_or_create(
            publication=publication,
            comments=resource.get("title"),
            url=resource.get("asset", {}).get("original", {}).get("url", ""),
            _type=PublicationResource.TYPE_SUP_INFO,
        )

    return redirect(reverse("journals:manage_publication_resources", args=(doi_label,)))


@method_decorator(login_required, name="dispatch")
@method_decorator(
    permission_required("scipost.can_draft_publication", raise_exception=True),
    name="dispatch",
)
class HTMXInlinePublicationResourceListView(HTMXInlineCRUDModelListView):
    model = PublicationResource
    model_form_view_url = "journals:_hx_publication_resource"
    add_form_class = HTMXInlinePublicationResourceForm

    def get_queryset(self):
        self.doi = self.kwargs.get("doi_label")
        self.publication = get_object_or_404(Publication, doi_label=self.doi)
        resources = PublicationResource.objects.filter(publication=self.publication)
        return self._append_model_form_view_url(resources, doi_label=self.doi)

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context["publication"] = self.publication
        return context


class HTMXInlinePublicationResourceFormView(HTMXInlineCRUDModelFormView):
    form_class = HTMXInlinePublicationResourceForm
    instance_li_template_name = "journals/publication_resource_li.html"


class DraftPublicationApprovalView(PermissionsMixin, UpdateView):
    permission_required = "scipost.can_draft_publication"
    queryset = Publication.objects.drafts()
    slug_field = slug_url_kwarg = "doi_label"
    form_class = DraftPublicationApprovalForm
    template_name = "journals/publication_approval_form.html"


@method_decorator(transaction.atomic, name="dispatch")
class PublicationPublishView(PermissionsMixin, RequestViewMixin, UpdateView):
    permission_required = "scipost.can_publish_accepted_submission"
    queryset = Publication.objects.unpublished()
    slug_field = slug_url_kwarg = "doi_label"
    form_class = PublicationPublishForm
    template_name = "journals/publication_publish_form.html"


@permission_required("scipost.can_publish_accepted_submission", return_403=True)
def manage_metadata(request, doi_label=None):
    if doi_label:
        publication = get_object_or_404(Publication, doi_label=doi_label)
        associate_generic_funder_form = FunderSelectForm()
        context = {
            "publication": publication,
            "associate_generic_funder_form": associate_generic_funder_form,
        }
        return render(request, "journals/manage_metadata_for_publication.html", context)

    publications_list = Publication.objects.all()
    # Use Paginator to reduce request size.
    paginator = Paginator(publications_list, 20)
    page = request.GET.get("page")
    try:
        publications = paginator.page(page)
    except PageNotAnInteger:
        # If page is not an integer, deliver first page.
        publications = paginator.page(1)
    except EmptyPage:
        # If page is out of range (e.g. 9999), deliver last page of results.
        publications = paginator.page(paginator.num_pages)

    context = {
        "publications": publications,
        "page_obj": publications,
        "paginator": paginator,
    }
    return render(request, "journals/manage_metadata.html", context)


@permission_required("scipost.can_draft_publication", return_403=True)
@transaction.atomic
def reset_authors(request, doi_label: str) -> HttpResponse:
    publication = get_object_or_404(Publication, doi_label=doi_label)
    if not publication.is_draft and not request.user.has_perm(
        "scipost.can_publish_accepted_submission"
    ):
        raise Http404("You do not have permission to edit this non-draft Publication")

    publication.reset_author_associations()

    return redirect(reverse("journals:add_author", kwargs={"doi_label": doi_label}))


@permission_required("scipost.can_draft_publication", return_403=True)
@transaction.atomic
def add_author(request: HttpRequest, doi_label: str) -> HttpResponse:
    """
    Link authors (via their Profile) to a Publication.

    To be used for registered Contributors who have not claimed authorship,
    as well as for unregistered authors.

    This is important for the Crossref metadata, in which all authors must appear.
    """
    publication = get_object_or_404(Publication, doi_label=doi_label)
    if not publication.is_draft and not request.user.has_perm(
        "scipost.can_publish_accepted_submission"
    ):
        raise Http404("You do not have permission to edit this non-draft Publication")

    if (
        request.method == "GET"
        and not PublicationAuthorsTable.objects.filter(publication=publication).exists()
    ):
        publication.reset_author_associations()

    form = ProfileSelectForm(request.POST or None)
    if form.is_valid() and (
        selected_author_id := int(request.POST.get("selected_author_id"))
    ):
        pub_author, created = PublicationAuthorsTable.objects.update_or_create(
            publication=publication,
            order=selected_author_id,
            defaults={"profile": form.cleaned_data["profile"]},
        )

        response = render(
            request,
            "journals/add_author_table_tr.html",
            {
                "author": {
                    "name_tex": publication.tex_author_info[selected_author_id - 1][0],
                    "profile": pub_author.profile,
                },
                "author_id": selected_author_id,
                "selected_author_id": selected_author_id,
                "publication": publication,
            },
        )
        response["HX-Retarget"] = f"#author_list_tr_{selected_author_id}"
        return response

    authors = []
    publication_authors: dict[int, PublicationAuthorsTable] = {
        pub_author.order: pub_author
        for pub_author in PublicationAuthorsTable.objects.filter(
            publication=publication
        ).select_related("profile", "profile__contributor")
    }
    for i, (name, superscripts) in enumerate(publication.tex_author_info, 1):
        publication_author = publication_authors.get(i)
        profile_matches: QuerySet[Profile] | None = (
            Profile.objects.search(name) if publication_author is None else None
        )
        profile = publication_author.profile if publication_author else None

        first_name_tex, last_name_tex = name.split(" ", 1)
        new_profile_url = (
            reverse_lazy("profiles:profile_create")
            + f"?first_name={first_name_tex}&last_name={last_name_tex}"
        )

        author_dict: dict[str, Any] = {
            "name_tex": name,
            "superscripts": superscripts,
            "profile": profile,
            "profile_matches": profile_matches,
            "new_profile_url": new_profile_url,
        }

        authors.append(author_dict)

    context = {
        "publication": publication,
        "form": form,
        "author_list": authors,
    }
    return render(request, "journals/add_author.html", context)


@permission_required("scipost.can_draft_publication", return_403=True)
@transaction.atomic
def delete_author_profile(
    request: HttpRequest, doi_label: str, author_order: int
) -> HttpResponse:
    """
    Delete the Profile association for a given author in a Publication.
    Redirects to main add authors page to rerender the whole table.
    """
    publication = get_object_or_404(Publication, doi_label=doi_label)
    if not publication.is_draft and not request.user.has_perm(
        "scipost.can_publish_accepted_submission"
    ):
        raise Http404("You do not have permission to edit this non-draft Publication")

    PublicationAuthorsTable.objects.filter(
        publication=publication, order=author_order
    ).delete()

    return redirect(reverse("journals:add_author", kwargs={"doi_label": doi_label}))


@permission_required("scipost.can_draft_publication", return_403=True)
@transaction.atomic
def author_affiliations(request, doi_label: str) -> HttpResponse:
    publication = get_object_or_404(Publication, doi_label=doi_label)
    if not publication.is_draft and not request.user.has_perm(
        "scipost.can_publish_accepted_submission"
    ):
        raise PermissionDenied(
            "You do not have permission to edit this non-draft Publication"
        )

    if not (
        (affil_info := list(zip(*publication.tex_author_info)))
        and (author_info := list(zip(*publication.tex_affiliations)))
        and len(affil_info) == len(author_info)
        and all(author_info[0])  # Check that author names are not empty
        and all(author_info[1])  # Check that author superscripts are not empty
        and all(affil_info[0])  # Check that affiliation identifiers are not empty
        and all(affil_info[1])  # Check that affiliations are not empty
    ):
        messages.warning(
            request,
            "Possibly malformed information in the publication "
            "if affiliations are not intentionally empty."
            "Please check that the publication has authors and affiliations defined, "
            'and that they are appropriately surrounded by "%%%TODO: ____" blocks.',
        )

    form = AuthorsTableOrganizationSelectForm(request.POST or None)

    organizations = {
        identifier: Organization.objects.filter(pk=value).first()
        if request.POST and (value := request.POST.get(f"affiliation_id_{identifier}"))
        else None
        for identifier, _ in publication.tex_affiliations
    }
    affiliations = [
        (i, t, o)
        for (i, t), o in zip(publication.tex_affiliations, organizations.values())
    ]
    context = {
        "publication": publication,
        "form": form,
        "affiliations": affiliations,
    }

    if request.POST:
        if not request.POST.get("submit"):
            context = {
                "checked_row_id": request.POST["checked_row_id"],
                "organization": Organization.objects.get(
                    pk=form["organization"].value()
                ),
            }

            response = render(
                request, "journals/author_affiliations_orgcell.html", context
            )
            response.headers["HX-Retarget"] = (
                "#organization_column_" + request.POST["checked_row_id"]
            )

            return response
        else:
            # First we need to check if all of the affiliations exist.
            total_affiliations_from_tex = len(
                list(filter(lambda x: x.startswith("affiliation_id_"), request.POST))
            )
            total_non_empty_affiliations = len(
                list(filter(lambda x: x is not None, organizations.values()))
            )

            if total_non_empty_affiliations != total_affiliations_from_tex:
                messages.warning(
                    request,
                    "<h3>%s</h3>Failed: Make sure that all affiliations are selected."
                    % publication.doi_label,
                )

                return render(request, "journals/author_affiliations.html", context)
            else:
                authors = PublicationAuthorsTable.objects.filter(
                    publication=publication
                )
                global_affiliations = [
                    v for k, v in organizations.items() if k.startswith("UN_")
                ]
                for author, (name, affs) in zip(authors, publication.tex_author_info):
                    author.affiliations.set(
                        global_affiliations
                        + [org for aff_id in affs if (org := organizations.get(aff_id))]
                    )

                publication.cf_author_affiliation_indices_list = []
                publication.save()

                return publication_detail(request, doi_label)

    return render(request, "journals/author_affiliations.html", context)


@permission_required("scipost.can_draft_publication", return_403=True)
def update_references(request, doi_label):
    """
    Update the References for a certain Publication.
    """
    publication = get_object_or_404(Publication, doi_label=doi_label)
    if not publication.is_draft and not request.user.has_perm(
        "scipost.can_publish_accepted_submission"
    ):
        raise Http404("You do not have permission to edit this non-draft Publication")

    references = publication.references.all()
    formset = ReferenceFormSet(
        request.POST or None,
        queryset=references,
        publication=publication,
        extra=request.GET.get("extra"),
    )

    if request.GET.get("prefill"):
        formset.prefill()

    if formset.is_valid():
        formset.save()
        messages.success(request, "References saved")
        return redirect(publication.get_absolute_url())

    context = {
        "publication": publication,
        "formset": formset,
    }
    return render(request, "journals/update_references.html", context)


class CitationUpdateView(
    PublicationMixin, ProdSupervisorPublicationPermissionMixin, UpdateView
):
    """
    Populates the citation_list dictionary entry in the metadata field in a Publication instance.
    """

    form_class = CitationListBibitemsForm
    template_name = "journals/create_citation_list_metadata.html"

    def get_success_url(self):
        return reverse_lazy(
            "journals:create_citation_list_metadata",
            kwargs={"doi_label": self.object.doi_label},
        )


def _hx_citation_list_item_delete(request, doi_label, index: int):
    """
    Deletes a citation entry at the given index.
    """
    if not request.user.has_perm("scipost.can_draft_publication"):
        return HTMXPermissionsDenied(
            "You do not have permission to delete a citation in this Publication"
        )

    publication = get_object_or_404(Publication, doi_label=doi_label)
    if (
        not request.user.has_perm("scipost.can_publish_accepted_submission")
        and not publication.is_draft
    ):
        return HTMXPermissionsDenied(
            "You do not have permission to delete a citation in this non-draft Publication"
        )

    if publication.metadata is None:
        return HTMXResponse("No metadata found", tag="danger")
    elif "citation_list" not in publication.metadata:
        return HTMXResponse("No citation list found", tag="danger")

    try:
        publication.metadata["citation_list"].pop(index)
    except IndexError:
        return HTMXResponse(
            f"Index {index} out of range ({len(publication.metadata['citation_list'])})",
            tag="danger",
        )
    publication.save()

    return HttpResponse("")


def _hx_citation_list_item_form(request, doi_label, index: int | None = None):
    """
    Renders a form to create or edit a citation entry at the given index.
    """
    if not request.user.has_perm("scipost.can_draft_publication"):
        return HTMXPermissionsDenied(
            "You do not have permission to edit this Publication"
        )

    publication = get_object_or_404(Publication, doi_label=doi_label)
    if (
        not request.user.has_perm("scipost.can_publish_accepted_submission")
        and not publication.is_draft
    ):
        return HTMXPermissionsDenied(
            "You do not have permission to edit this non-draft Publication"
        )

    if index is not None:
        if index >= len(publication.metadata["citation_list"]):
            return HTMXResponse("Index out of range", tag="danger")
        else:
            form = CitationListItemForm(
                request.POST or None,
                instance=publication,
                index=index,
            )
    else:
        index = len(publication.metadata["citation_list"])
        form = CitationListItemForm(
            request.POST or None,
            instance=publication,
            index=index,
        )

    if request.method == "POST":
        if form.is_valid():
            form.save()
            doi = form.cleaned_data.get("doi")
            return TemplateResponse(
                request,
                "journals/_hx_citation_list_item.html",
                {
                    "citation": {"key": "ref" + str(index + 1), "doi": doi},
                    "publication": publication,
                    "index": index,
                },
            )

    return TemplateResponse(
        request,
        "journals/_hx_citation_list_item_form.html",
        {
            "form": form,
            "publication": publication,
            "index": index,
        },
    )


def _hx_citation_list_bibitems_form(request, doi_label):
    if not request.user.has_perm("scipost.can_draft_publication"):
        return HTMXPermissionsDenied(
            "You do not have permission to edit this Publication"
        )

    publication = get_object_or_404(Publication, doi_label=doi_label)
    if (
        not request.user.has_perm("scipost.can_publish_accepted_submission")
        and not publication.is_draft
    ):
        return HTMXPermissionsDenied(
            "You do not have permission to edit this non-draft Publication"
        )

    form = CitationListBibitemsForm(request.POST or None, instance=publication)
    if form.is_valid():
        form.save()
        messages.success(request, "Citation list updated")
        return HttpResponse("")

    context = {
        "form": form,
        "publication": publication,
    }
    return TemplateResponse(
        request, "journals/_hx_citation_list_bibitems_form.html", context
    )


class AbstractJATSUpdateView(
    PublicationMixin, ProdSupervisorPublicationPermissionMixin, UpdateView
):
    """
    Add or update the JATS version of the abstract.
    This should be produced separately using pandoc.
    """

    form_class = AbstractJATSForm
    template_name = "journals/create_abstract_jats.html"

    def get_success_url(self):
        return reverse(
            "journals:abstract_jats",
            kwargs={"doi_label": self.object.doi_label},
        )

    def post(self, request: HttpRequest, *args: str, **kwargs: Any) -> HttpResponse:
        if request.POST.get("convert_button"):
            # Change the abstract_jats field value to "LMAO"
            self.get_form().data["abstract_jats"] = "LMAO"

        return super().post(request, *args, **kwargs)


class FundingInfoView(
    PublicationMixin, ProdSupervisorPublicationPermissionMixin, UpdateView
):
    """
    Add/update funding statement to the xml_metadata
    """

    form_class = FundingInfoForm
    template_name = "journals/create_funding_info_metadata.html"

    # Delete the funding statement if the form is submitted empty
    def form_valid(self, form):
        if form.cleaned_data.get("funding_statement", "") == "":
            self.object.metadata["funding_statement"] = ""
            self.object.save()
            return redirect(self.get_success_url())

        return super().form_valid(form)


@permission_required("scipost.can_draft_publication", return_403=True)
@transaction.atomic
def _hx_publication_metadata_add_grant_funding(request, doi_label):
    """
    Called by an Editorial Administrator.
    This associates a grant from the database to this publication.
    """
    publication = get_object_or_404(Publication, doi_label=doi_label)
    if not publication.is_draft and not request.user.has_perm(
        "scipost.can_publish_accepted_submission"
    ):
        raise Http404("You do not have permission to edit this non-draft Publication")
    grant_select_form = GrantSelectForm(request.POST or None)
    if grant_select_form.is_valid():
        publication.grants.add(grant_select_form.cleaned_data["grant"])
        publication.doideposit_needs_updating = True
        publication.save()
        messages.success(request, "Grant added to publication.")
    return render(
        request,
        "journals/_hx_publication_metadata_add_grant_funding.html",
        {
            "form": grant_select_form,
            "publication": publication,
        },
    )


@permission_required("scipost.can_draft_publication", return_403=True)
@transaction.atomic
def _hx_publication_metadata_delete_grant_funding(request, doi_label, grant_id):
    """
    Called by an Editorial Administrator.
    This deletes a grant of this publication from the database.
    """
    publication = get_object_or_404(Publication, doi_label=doi_label)
    grant = get_object_or_404(Grant, id=grant_id)
    if not publication.is_draft and not request.user.has_perm(
        "scipost.can_publish_accepted_submission"
    ):
        raise Http404("You do not have permission to edit this non-draft Publication")

    if grant in publication.grants.all():
        publication.grants.remove(grant)
        messages.success(request, "Grant removed from publication.")
    return HttpResponse("")


@permission_required("scipost.can_draft_publication", return_403=True)
@transaction.atomic
def _hx_publication_metadata_add_generic_funding(request, doi_label):
    """
    Called by an Editorial Administrator.
    This associates a funder (generic, not via grant) from the database to this publication.
    """
    publication = get_object_or_404(Publication, doi_label=doi_label)
    if not publication.is_draft and not request.user.has_perm(
        "scipost.can_publish_accepted_submission"
    ):
        raise Http404("You do not have permission to edit this non-draft Publication")
    funder_select_form = FunderSelectForm(request.POST or None)
    if funder_select_form.is_valid():
        publication.funders_generic.add(funder_select_form.cleaned_data["funder"])
        publication.save()
        messages.success(request, "Generic funder added to publication")
    return render(
        request,
        "journals/_hx_publication_metadata_add_generic_funding.html",
        {
            "form": funder_select_form,
            "publication": publication,
        },
    )


@permission_required("scipost.can_draft_publication", return_403=True)
@transaction.atomic
def _hx_publication_metadata_delete_generic_funding(request, doi_label, funder_id):
    """
    Called by an Editorial Administrator.
    This deletes a funder (generic, not via funder) of this publication from the database.
    """
    publication = get_object_or_404(Publication, doi_label=doi_label)
    funder = get_object_or_404(Funder, id=funder_id)
    if not publication.is_draft and not request.user.has_perm(
        "scipost.can_publish_accepted_submission"
    ):
        raise Http404("You do not have permission to edit this non-draft Publication")

    if funder in publication.funders_generic.all():
        publication.funders_generic.remove(funder)
        messages.success(request, "Generic funder removed from publication.")
    return HttpResponse("")


class CreatePublicationMetadataXMLView(
    PublicationMixin, ProdSupervisorPublicationPermissionMixin, UpdateView
):
    """
    To be called by an EdAdmin (or Production Supervisor) after the authors,
    author ordering, affiliations, citation_list, funding_info
    entries have been filled. Populates the metadata_xml field of a Publication instance.
    The contents can then be sent to Crossref for registration.
    """

    form_class = CreatePublicationMetadataXMLForm
    template_name = "journals/create_publication_metadata_xml.html"

    def get_context_data(self, **kwargs: Any) -> Dict[str, Any]:
        context = super().get_context_data(**kwargs)
        form = context["form"]
        valid, errors, xml_str = form.validate_xml(form.xml_str)

        return {**context, "valid": valid, "errors": errors, "xml_str": xml_str}


class CreateProceedingsMetadataXMLView(UpdateView):
    """
    To be called by an EdAdmin (or Production Supervisor) after all proceedings
    publications have been published. Populates the metadata_xml field of a Proceedings instance.
    The contents can then be sent to Crossref for registration.
    """

    model = Proceedings
    form_class = CreateProceedingsMetadataXMLForm
    template_name = "journals/create_proceedings_metadata_xml.html"

    def get_context_data(self, **kwargs: Any) -> Dict[str, Any]:
        context = super().get_context_data(**kwargs)
        form = context["form"]
        valid, errors, xml_str = form.validate_xml(form.xml_str)

        return {**context, "valid": valid, "errors": errors, "xml_str": xml_str}

    def get_success_url(self) -> str:
        return reverse("journals:manage_proceedings_metadata")


@permission_required("scipost.can_draft_publication", return_403=True)
@transaction.atomic
def metadata_xml_deposit(request, doi_label, option="test"):
    """
    Crossref metadata deposit.
    If test==True, test the metadata_xml using the Crossref test server.
    Makes use of the python requests module.
    """
    publication = get_object_or_404(Publication, doi_label=doi_label)
    if not publication.is_draft and not request.user.has_perm(
        "scipost.can_publish_accepted_submission"
    ):
        raise Http404("You do not have permission to access this non-draft Publication")
    if (
        not request.user.has_perm("scipost.can_publish_accepted_submission")
        and option != "test"
    ):
        raise PermissionDenied(
            "You do not have permission to do real Crossref deposits"
        )

    if publication.metadata_xml is None:
        messages.warning(
            request,
            "This publication has no metadata. Produce it first before saving it.",
        )
        return redirect(
            reverse(
                "journals:create_publication_metadata_xml",
                kwargs={"doi_label": publication.doi_label},
            )
        )

    timestamp = publication.metadata_xml.partition("<timestamp>")[2].partition(
        "</timestamp>"
    )[0]
    doi_batch_id = publication.metadata_xml.partition("<doi_batch_id>")[2].partition(
        "</doi_batch_id>"
    )[0]

    # Find Crossref xml files
    path = ""
    if publication.in_issue:
        path += "{issue_path}/{paper_nr}/{doi_label}_Crossref".format(
            issue_path=publication.in_issue.path,
            paper_nr=publication.get_paper_nr(),
            doi_label=publication.doi_label.replace(".", "_"),
        )

    if publication.in_journal:
        path += "SCIPOST_JOURNALS/{journal_doi_label}/{paper_nr}/{doi_label}_Crossref".format(
            journal_doi_label=publication.in_journal.doi_label,
            paper_nr=publication.get_paper_nr(),
            doi_label=publication.doi_label.replace(".", "_"),
        )

    os.makedirs(settings.MEDIA_ROOT + path, exist_ok=True)
    path_wo_timestamp = path + ".xml"
    path += "_{timestamp}.xml".format(timestamp=timestamp)

    valid = True
    response_headers = None
    response_text = None
    if os.path.isfile(settings.MEDIA_ROOT + path):
        # Deposit already done before.
        valid = False
    else:
        # New deposit, go for it.
        if option == "deposit" and not settings.DEBUG:
            # CAUTION: Real deposit only on production!
            url = "https://doi.crossref.org/servlet/deposit"
        else:
            url = "https://test.crossref.org/servlet/deposit"

        # First perform the actual deposit to Crossref
        files = {
            "fname": (
                "metadata.xml",
                publication.metadata_xml.encode("utf-8"),
                "multipart/form-data",
            ),
            "operation": (
                None,
                "doMDUpload",
                "multipart/form-data",
            ),
            "login_id": (
                None,
                settings.CROSSREF_LOGIN_ID,
                "multipart/form-data",
            ),
            "login_passwd": (
                None,
                settings.CROSSREF_LOGIN_PASSWORD,
                "multipart/form-data",
            ),
        }
        r = requests.post(url, files=files)
        response_headers = r.headers
        response_text = r.text

        # Then create the associated Deposit object (saving the metadata to a file)
        if option == "deposit":
            deposit = Deposit(
                publication=publication,
                timestamp=timestamp,
                doi_batch_id=doi_batch_id,
                metadata_xml=publication.metadata_xml,
                deposition_date=timezone.now(),
            )
            deposit.response_text = r.text

            # Save the filename with timestamp
            f = open(settings.MEDIA_ROOT + path, "w", encoding="utf-8")
            f.write(publication.metadata_xml)
            f.close()

            # Update Crossref timestamp-free file to latest deposit
            shutil.copyfile(
                settings.MEDIA_ROOT + path, settings.MEDIA_ROOT + path_wo_timestamp
            )
            deposit.metadata_xml_file = path
            deposit.save()
            publication.latest_crossref_deposit = timezone.now()
            publication.save()

    context = {
        "option": option,
        "publication": publication,
        "response_headers": response_headers,
        "response_text": response_text,
        "valid": valid,
    }
    return render(request, "journals/metadata_xml_deposit.html", context)


@permission_required("scipost.can_publish_accepted_submission", return_403=True)
def mark_deposit_success(request, deposit_id: int, success: int) -> HttpResponse:
    """Mark a crossref metadata deposit as successful or unsuccessful."""
    deposit = get_object_or_404(Deposit, pk=deposit_id)

    if success == 1:
        deposit.deposit_successful = True
    elif success == 0:
        deposit.deposit_successful = False
    else:
        return Http404

    deposit.save()
    return redirect("journals:manage_metadata")


@permission_required("scipost.can_publish_accepted_submission", return_403=True)
def produce_metadata_DOAJ(request, doi_label: str) -> HttpResponse:
    """Produce metadata report for DOAJ."""

    publication = get_object_or_404(Publication, doi_label=doi_label)
    form = CreatePublicationMetadataDOAJForm(
        request.POST or None, instance=publication, request=request
    )
    if form.is_valid():
        form.save()
        messages.success(
            request,
            "<h3>%s</h3>Successfully produced metadata DOAJ." % publication.doi_label,
        )
        return redirect(
            reverse("journals:manage_metadata", kwargs={"doi_label": doi_label})
        )
    context = {"publication": publication, "form": form}
    return render(request, "journals/metadata_doaj_create.html", context)


@permission_required("scipost.can_publish_accepted_submission", return_403=True)
@transaction.atomic
def metadata_DOAJ_deposit(request, doi_label: str) -> HttpResponse:
    """Deposit metadata to DOAJ. Makes use of the python requests module."""
    publication = get_object_or_404(Publication, doi_label=doi_label)

    if not publication.metadata_DOAJ:
        messages.warning(
            request,
            "<h3>%s</h3>Failed: please first produce "
            "DOAJ metadata before depositing." % publication.doi_label,
        )
        return redirect(
            reverse("journals:manage_metadata", kwargs={"doi_label": doi_label})
        )

    # timestamp = publication.metadata_xml.partition('<timestamp>')[2].partition('</timestamp>')[0]
    timestamp = timezone.now().strftime("%Y%m%d%H%M%S")

    # Find DOAJ json files
    path = ""
    if publication.in_issue:
        path += "{issue_path}/{paper_nr}/{doi_label}_DOAJ".format(
            issue_path=publication.in_issue.path,
            paper_nr=publication.get_paper_nr(),
            doi_label=publication.doi_label.replace(".", "_"),
        )
    elif publication.in_journal:
        path += (
            "SCIPOST_JOURNALS/{journal_doi_label}/{paper_nr}/{doi_label}_DOAJ".format(
                journal_doi_label=publication.in_journal.doi_label,
                paper_nr=publication.get_paper_nr(),
                doi_label=publication.doi_label.replace(".", "_"),
            )
        )

    os.makedirs(settings.MEDIA_ROOT + path, exist_ok=True)
    path_wo_timestamp = path + ".json"
    path += "_{timestamp}.json".format(timestamp=timestamp)

    if os.path.isfile(settings.MEDIA_ROOT + path):
        errormessage = "The metadata file for this metadata timestamp already exists"
        return render(
            request, "scipost/error.html", context={"errormessage": errormessage}
        )

    url = "https://doaj.org/api/v2/articles"
    params = {
        "api_key": settings.DOAJ_API_KEY,
    }
    try:
        doaj_success = True
        r = requests.post(url, params=params, json=publication.metadata_DOAJ)
        r.raise_for_status()
    except requests.exceptions.HTTPError:
        doaj_success = False
        messages.warning(
            request,
            "<h3>%s</h3>Failed: Post went wrong, response text: %s"
            % (publication.doi_label, r.text),
        )

    # Then create the associated Deposit object (saving the metadata to a file)
    deposit = DOAJDeposit(
        publication=publication,
        timestamp=timestamp,
        metadata_DOAJ=publication.metadata_DOAJ,
        deposition_date=timezone.now(),
    )
    deposit.response_text = r.text

    # Save a copy to the filename with and without timestamp
    f = open(settings.MEDIA_ROOT + path, "w")
    f.write(json.dumps(publication.metadata_DOAJ))
    f.close()

    # Copy file
    shutil.copyfile(settings.MEDIA_ROOT + path, settings.MEDIA_ROOT + path_wo_timestamp)

    # Save the database entry
    deposit.metadata_DOAJ_file = path
    deposit.save()

    if doaj_success:
        messages.success(
            request,
            "<h3>%s</h3>Successful deposit of metadata DOAJ." % publication.doi_label,
        )
        mark_doaj_deposit_success(request, deposit.id, 1)
    else:
        print("DOAJ deposit failed", deposit.id)
        mark_doaj_deposit_success(request, deposit.id, 0)

    return redirect(
        reverse("journals:manage_metadata", kwargs={"doi_label": doi_label})
    )


@permission_required("scipost.can_manage_ontology", return_403=True)
def publication_add_topic(request, doi_label: str) -> HttpResponse:
    """
    Add a predefined Topic to an existing Publication object.
    This also adds the Topic to all Submissions of this Publication.
    """
    publication = get_object_or_404(Publication, doi_label=doi_label)
    select_topic_form = SelectTopicForm(request.POST or None)
    if select_topic_form.is_valid():
        for topic in select_topic_form.cleaned_data["topic"]:
            publication.topics.add(topic)
            for sub in publication.accepted_submission.thread:
                sub.topics.add(topic)
        messages.success(request, "Successfully linked Topic(s) to this publication")
    return redirect(
        reverse(
            "scipost:publication_detail", kwargs={"doi_label": publication.doi_label}
        )
    )


@permission_required("scipost.can_manage_ontology", return_403=True)
def publication_remove_topic(request, doi_label, slug):
    """
    Remove the Topic from the Publication, and from all associated Submissions.
    """
    publication = get_object_or_404(Publication, doi_label=doi_label)
    topic = get_object_or_404(Topic, slug=slug)
    publication.topics.remove(topic)
    for sub in publication.accepted_submission.thread:
        sub.topics.remove(topic)
    messages.success(request, "Successfully removed Topic")
    return redirect(
        reverse(
            "scipost:publication_detail", kwargs={"doi_label": publication.doi_label}
        )
    )


@login_required
@permission_required("scipost.can_publish_accepted_submission", return_403=True)
def define_pubfracs(request, doi_label):
    """
    Defines PubFracs based on balanced affiliations algorithm.
    """
    publication = get_object_or_404(Publication, doi_label=doi_label)
    publication.recalculate_pubfracs()
    return redirect(
        reverse(
            "scipost:publication_detail", kwargs={"doi_label": publication.doi_label}
        )
    )


@login_required
@permission_required("scipost.can_publish_accepted_submission", return_403=True)
def adjust_pubfracs(request, doi_label):
    """
    Set the relative support obtained from Organizations
    for the research contained in a Publication.

    This view is accessible to EdAdmin.
    """
    publication = get_object_or_404(Publication, doi_label=doi_label)
    # Create PubFrac objects from existing organization links
    for org in publication.get_affiliations():
        pubfrac, created = PubFrac.objects.get_or_create(
            publication=publication, organization=org
        )
    formset = PubFracsFormSet(request.POST or None, queryset=publication.pubfracs.all())
    if formset.is_valid():
        formset.save()
        messages.success(request, "Funding fractions successfully allocated.")
        return redirect(publication.get_absolute_url())
    context = {
        "publication": publication,
        "formset": formset,
    }
    return render(request, "journals/adjust_pubfracs.html", context)


@permission_required("scipost.can_publish_accepted_submission", return_403=True)
def mark_doaj_deposit_success(request, deposit_id: int, success: int) -> HttpResponse:
    """Mark a DOAJ metadata deposit as successful or unsuccessful."""
    deposit = get_object_or_404(DOAJDeposit, pk=deposit_id)

    if success == 1:
        deposit.deposit_successful = True
    elif success == 0:
        deposit.deposit_successful = False
    else:
        raise Http404

    deposit.save()
    return redirect("journals:manage_metadata")


@permission_required("scipost.can_publish_accepted_submission", return_403=True)
def harvest_citedby_list(request):
    publications = Publication.objects.order_by("-publication_date")
    context = {"publications": publications}
    return render(request, "journals/harvest_citedby_list.html", context)


@permission_required("scipost.can_publish_accepted_submission", return_403=True)
@transaction.atomic
def harvest_citedby_links(request, doi_label):
    publication = get_object_or_404(Publication, doi_label=doi_label)
    update_citedby(doi_label)
    return render(
        request, "journals/harvest_citedby_links.html", {"publication": publication}
    )


@login_required
def sign_existing_report(request, report_id):
    """
    Allows the author of a Report, originally submitted anonymously,
    to sign the Report.
    """
    report = get_object_or_404(Report, pk=report_id)
    if report.author != request.user.contributor:
        errormessage = "Only the author of this Report can change its anonymity status"
        return render(
            request, "scipost/error.html", context={"errormessage": errormessage}
        )
    form = ConfirmationForm(request.POST or None)
    if form.is_valid():
        if form.cleaned_data["confirm"] == "True":
            report.anonymous = False
            report.doideposit_needs_updating = True
            report.save()
            messages.success(request, "Your Report is now publicly signed.")
        else:
            messages.error(request, "Report signing operation cancelled.")
        return redirect(reverse("scipost:personal_page"))
    context = {"report": report, "form": form}
    return render(request, "journals/sign_existing_report.html", context)


@permission_required("scipost.can_publish_accepted_submission", return_403=True)
def manage_report_metadata(request) -> HttpResponse:
    """
    This page offers Editorial Administrators tools for managing
    the metadata of Reports.
    """
    reports = Report.objects.all()
    ready_for_deposit = request.GET.get("ready_for_deposit") == "1"

    if ready_for_deposit:
        reports = (
            reports.annotate(
                paper_published=Exists(
                    Publication.objects.filter(
                        accepted_submission__thread_hash=OuterRef(
                            "submission__thread_hash"
                        ),
                        status=PUBLICATION_PUBLISHED,
                    )
                ),
                successful_deposit=Exists(
                    GenericDOIDeposit.objects.filter(
                        object_id=OuterRef("id"),
                        content_type=ContentType.objects.get_for_model(Report),
                        deposit_successful=True,
                    )
                ),
            )
            .exclude(needs_doi=False)
            .filter(
                paper_published=True,
                successful_deposit=False,
            )
        )

    needing_update = request.GET.get("needing_update") == "1"
    if needing_update:
        reports = reports.filter(
            Q(needs_doi=None) | Q(needs_doi=True, doideposit_needs_updating=True)
        ).filter(submission__status=Submission.PUBLISHED)

    paginator = Paginator(reports, 25)
    page = request.GET.get("page")
    try:
        reports = paginator.page(page)
    except PageNotAnInteger:
        reports = paginator.page(1)
    except EmptyPage:
        reports = paginator.page(paginator.num_pages)

    context = {
        "reports": reports,
        "page_obj": reports,
        "paginator": paginator,
    }
    return render(request, "journals/manage_report_metadata.html", context)


@permission_required("scipost.can_publish_accepted_submission", return_403=True)
def manage_comment_metadata(request):
    """
    This page offers Editorial Administrators tools for managing
    the metadata of Comments.
    """
    comments = Comment.objects.all()

    paginator = Paginator(comments, 25)
    page = request.GET.get("page")
    try:
        comments = paginator.page(page)
    except PageNotAnInteger:
        comments = paginator.page(1)
    except EmptyPage:
        comments = paginator.page(paginator.num_pages)

    context = {
        "comments": comments,
        "page_obj": comments,
        "paginator": paginator,
    }
    return render(request, "journals/manage_comment_metadata.html", context)


@permission_required("scipost.can_publish_accepted_submission", return_403=True)
def manage_update_metadata(request):
    """
    This page offers Editorial Administrators tools for managing
    the metadata of PublicationUpdates.
    """
    updates = PublicationUpdate.objects.all().order_by("-publication_date")

    paginator = Paginator(updates, 25)
    page = request.GET.get("page")
    try:
        updates = paginator.page(page)
    except PageNotAnInteger:
        updates = paginator.page(1)
    except EmptyPage:
        updates = paginator.page(paginator.num_pages)

    context = {
        "updates": updates,
        "page_obj": updates,
        "paginator": paginator,
    }
    return render(request, "journals/manage_update_metadata.html", context)


@permission_required("scipost.can_publish_accepted_submission", return_403=True)
def manage_proceedings_metadata(request):
    """
    This page offers Editorial Administrators tools for managing
    the metadata of Proceedings.
    """
    proceedings = Proceedings.objects.all()

    paginator = Paginator(proceedings, 25)
    page = request.GET.get("page")
    try:
        proceedings = paginator.page(page)
    except PageNotAnInteger:
        proceedings = paginator.page(1)
    except EmptyPage:
        proceedings = paginator.page(paginator.num_pages)

    context = {
        "proceedings_set": proceedings,
        "page_obj": proceedings,
        "paginator": paginator,
    }
    return render(request, "journals/manage_proceedings_metadata.html", context)


@permission_required("scipost.can_publish_accepted_submission", return_403=True)
def mark_report_doi_needed(request, report_id, needed) -> HttpResponse:
    report = get_object_or_404(Report, pk=report_id)
    if needed == 1:
        report.needs_doi = True
    elif needed == 0:
        report.needs_doi = False
    else:
        raise Http404
    report.save()
    return redirect(reverse("journals:manage_report_metadata"))


@permission_required("scipost.can_publish_accepted_submission", return_403=True)
def mark_comment_doi_needed(request, comment_id, needed):
    comment = get_object_or_404(Comment, pk=comment_id)
    if needed == 1:
        comment.needs_doi = True
    elif needed == 0:
        comment.needs_doi = False
    else:
        raise Http404
    comment.save()
    return redirect(reverse("journals:manage_comment_metadata"))


@permission_required("scipost.can_publish_accepted_submission", return_403=True)
@transaction.atomic
def generic_metadata_xml_deposit(request, **kwargs):
    """
    Handle generic non-Publication metadata deposits at Crossref.

    Types of objects handled:

    * Reports
    * Comments
    * PublicationUpdates
    * Proceedings

    The metadata is created and immediately deposited at Crossref.

    For Reports and Comments, if there exists a relation to a
    SciPost-published object, the deposit uses Crossref's peer review content type.
    Otherwise the deposit is done as a dataset.

    For PublicationUpdates, the deposit type is `journal_article` and
    the journal is used as container.

    For Proceedings, the deposit type is `conference`.
    """
    domain = get_current_domain()

    type_of_object = kwargs["type_of_object"]
    object_id = int(kwargs["object_id"])

    if type_of_object == "report":
        _object = get_object_or_404(Report, id=object_id)
    elif type_of_object == "comment":
        _object = get_object_or_404(Comment, id=object_id)
    elif type_of_object == "update":
        _object = get_object_or_404(PublicationUpdate, id=object_id)
    elif type_of_object == "proceedings":
        _object = get_object_or_404(Proceedings, id=object_id)
    else:
        raise Http404

    if not _object.doi_label:
        _object.create_doi_label()
        _object.refresh_from_db()

    metadata_xml = ""
    timestamp = timezone.now().strftime("%Y%m%d%H%M%S")
    # create a doi_batch_id
    salt = ""
    for i in range(5):
        salt = salt + random.choice(string.ascii_letters)
    salt = salt.encode("utf8")
    idsalt = str(_object)[:10]
    idsalt = idsalt.encode("utf8")
    doi_batch_id = hashlib.sha1(salt + idsalt).hexdigest()

    if isinstance(_object, PublicationUpdate):
        metadata_xml = _object.xml(doi_batch_id=doi_batch_id)
    elif isinstance(_object, Proceedings):
        metadata_xml = _object.metadata_xml.encode("utf-8")
    else:  # Report or Comment
        relation_to_published = (
            _object.relation_to_published
        )  # Reports and Comments have this

        metadata_xml = (
            '<?xml version="1.0" encoding="UTF-8"?>\n'
            '<doi_batch version="4.4.1" xmlns="http://www.crossref.org/schema/4.4.1" '
            'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" '
            'xsi:schemaLocation="http://www.crossref.org/schema/4.4.1 '
            'http://www.crossref.org/shema/deposit/crossref4.4.1.xsd">\n'
            "<head>\n"
            "<doi_batch_id>" + str(doi_batch_id) + "</doi_batch_id>\n"
            "<timestamp>" + timestamp + "</timestamp>\n"
            "<depositor>\n"
            "<depositor_name>scipost</depositor_name>\n"
            "<email_address>" + settings.CROSSREF_DEPOSIT_EMAIL + "</email_address>\n"
            "</depositor>\n"
            "<registrant>scipost</registrant>\n"
            "</head>\n"
        )

        if relation_to_published:  # Reports and Comments have this
            metadata_xml += (
                "<body>\n"
                '<peer_review stage="' + relation_to_published["stage"] + '">\n'
                "<contributors>"
            )
            if _object.anonymous:
                metadata_xml += (
                    '<anonymous sequence="first" contributor_role="'
                    + relation_to_published["contributor_role"]
                    + '"/>'
                )
            else:
                metadata_xml += (
                    '<person_name sequence="first" contributor_role="'
                    + relation_to_published["contributor_role"]
                    + '">'
                    "<given_name>" + _object.author.user.first_name + "</given_name>"
                    "<surname>" + _object.author.user.last_name + "</surname>"
                    "</person_name>\n"
                )

            if isinstance(_object, Publication):
                url_to_declare = "https://{domain}{doi}".format(
                    domain=domain, doi=_object.get_absolute_url()
                )
            else:
                url_to_declare = "https://{domain}/{doi}".format(
                    domain=domain, doi=_object.doi_label
                )

            metadata_xml += (
                "</contributors>\n"
                "<titles><title>"
                + relation_to_published["title"]
                + "</title></titles>\n"
                "<review_date>"
                "<month>" + _object.date_submitted.strftime("%m") + "</month>"
                "<day>" + _object.date_submitted.strftime("%d") + "</day>"
                "<year>" + _object.date_submitted.strftime("%Y") + "</year>"
                "</review_date>\n"
                '<program xmlns="http://www.crossref.org/relations.xsd">\n'
                "<related_item>"
                "<description>" + relation_to_published["title"] + "</description>\n"
                '<inter_work_relation relationship-type="isReviewOf" identifier-type="doi">'
                + relation_to_published["isReviewOfDOI"]
                + "</inter_work_relation></related_item>\n"
                "</program>"
                "<doi_data><doi>" + _object.doi_string + "</doi>\n"
                "<resource>" + url_to_declare + "</resource></doi_data>\n"
                "</peer_review>\n"
                "</body>\n"
                "</doi_batch>\n"
            )

        else:  # Reports and Comments on not-yet-published objects
            metadata_xml += (
                "<body>\n"
                "<database>\n"
                '<database_metadata language="en">\n'
                "<titles><title>SciPost Reports and Comments</title></titles>\n"
                "</database_metadata>\n"
                '<dataset dataset_type="collection">\n'
                "<doi_data><doi>" + _object.doi_string + "</doi>\n"
                "<resource>https://"
                + domain
                + _object.get_absolute_url()
                + "</resource></doi_data>\n"
                "</dataset></database>\n"
                "</body></doi_batch>"
            )

    if not settings.CROSSREF_DEBUG:
        # CAUTION: Debug is False, production goes for real deposit!!!
        url = "https://doi.crossref.org/servlet/deposit"
    else:
        url = "https://test.crossref.org/servlet/deposit"

    files = {
        "fname": (
            "metadata.xml",
            metadata_xml.encode("utf-8"),
            "multipart/form-data",
        ),
        "operation": (
            None,
            "doMDUpload",
            "multipart/form-data",
        ),
        "login_id": (
            None,
            settings.CROSSREF_LOGIN_ID,
            "multipart/form-data",
        ),
        "login_passwd": (
            None,
            settings.CROSSREF_LOGIN_PASSWORD,
            "multipart/form-data",
        ),
    }
    r = requests.post(url, files=files)
    deposit = GenericDOIDeposit(
        content_type=ContentType.objects.get_for_model(_object),
        object_id=object_id,
        content_object=_object,
        timestamp=timestamp,
        doi_batch_id=doi_batch_id,
        metadata_xml=metadata_xml,
        deposition_date=timezone.now(),
        response=r.text,
    )
    deposit.save()
    context = {
        "response_headers": r.headers,
        "response_text": r.text,
        "manage_metadata_url": _object.__class__.get_metadata_management_url(),
    }
    return render(request, "journals/generic_metadata_xml_deposit.html", context)


@permission_required("scipost.can_publish_accepted_submission", return_403=True)
def mark_generic_deposit_success(request, deposit_id, success):
    deposit = get_object_or_404(GenericDOIDeposit, pk=deposit_id)
    if success == 1:
        deposit.deposit_successful = True
        deposit.content_object.doideposit_needs_updating = False
        deposit.content_object.save()
    elif success == 0:
        deposit.deposit_successful = False
    else:
        raise Http404
    deposit.save()

    return redirect(deposit.content_type.model_class().get_metadata_management_url())


@permission_required("scipost.can_publish_accepted_submission", return_403=True)
def email_object_made_citable(request, **kwargs):
    """
    This method sends an email to the author of a Report or a Comment,
    to notify that the object has been made citable (doi registered).
    """
    type_of_object = kwargs["type_of_object"]
    object_id = int(kwargs["object_id"])

    if type_of_object == "report":
        _object = get_object_or_404(Report, id=object_id)
        redirect_to = reverse("journals:manage_report_metadata")
        publication_citation = None
        publication_doi = None
        publication = (
            Publication.objects.filter(
                accepted_submission__thread_hash=_object.submission.thread_hash
            )
            .order_by("doi_label")
            .first()
        )
        if publication:
            publication_citation = publication.citation
            publication_doi = publication.doi_string
    elif type_of_object == "comment":
        _object = get_object_or_404(Comment, id=object_id)
        redirect_to = reverse("journals:manage_comment_metadata")
    else:
        raise Http404

    if not _object.doi_label:
        messages.warning(request, "This object does not have a DOI yet.")
        return redirect(redirect_to)

    if type_of_object == "report":
        DirectMailUtil(
            "journals/report_made_citable",
            report=_object,
            publication=publication,
        ).send_mail()
    else:
        DirectMailUtil(
            "journals/comment_made_citable",
            comment=_object,
        ).send_mail()
    messages.success(request, "Email sent")
    return redirect(redirect_to)


###########
# Viewing #
###########


def report_detail(request, doi_label):
    report = get_object_or_404(Report.objects.accepted(), doi_label=doi_label)
    return redirect(report.get_absolute_url())


def comment_detail(request, doi_label):
    comment = get_object_or_404(
        Comment.objects.vetted().regular_comments(), doi_label=doi_label
    )
    return redirect(comment.get_absolute_url())


def author_reply_detail(request, doi_label):
    comment = get_object_or_404(
        Comment.objects.vetted().author_replies(), doi_label=doi_label
    )
    return redirect(comment.get_absolute_url())


def publication_detail(request, doi_label):
    """
    The actual Publication detail page. This is visible for everyone if published or
    visible for Production Supervisors and Administrators if in draft.
    """
    publication = get_object_or_404(Publication, doi_label=doi_label)
    if not publication.is_published and not request.user.has_perm(
        "scipost.can_draft_publication"
    ):
        raise Http404("Publication is not publicly visible")

    publication.funders = list(
        publication.get_all_funders().select_related("organization")
    )

    prefetch_related_objects(
        [publication],
        Prefetch("pubfracs", queryset=PubFrac.objects.select_related("organization")),
        Prefetch(
            "authors",
            queryset=PublicationAuthorsTable.objects.select_related(
                "profile", "profile__contributor"
            ),
        ),
    )

    context = {
        "publication": publication,
        "affiliation_indices": publication.get_author_affiliation_indices_list(),
        "affiliations_list": publication.get_all_affiliations(),
        "journal": publication.get_journal(),
        "select_topic_form": SelectTopicForm(),
    }
    return render(request, "journals/publication_detail.html", context)


def publication_detail_pdf(request, doi_label):
    """
    The actual Publication pdf. This is visible for everyone if published or
    visible for Production Supervisors and Administrators if in draft.
    """
    publication = get_object_or_404(Publication, doi_label=doi_label)
    if not publication.is_published and not request.user.has_perm(
        "scipost.can_draft_publication"
    ):
        raise Http404("Publication is not publicly visible")
    if not publication.pdf_file:
        raise Http404("Publication has no associated pdf document")
    response = HttpResponse(publication.pdf_file.read(), content_type="application/pdf")
    response["Content-Disposition"] = (
        "filename=" + publication.doi_label.replace(".", "_") + ".pdf"
    )
    return response


def publication_update_detail(request, doi_label, update_nr):
    """
    Detail page for a PublicationUpdate.
    """
    update = get_object_or_404(
        PublicationUpdate, publication__doi_label=doi_label, number=update_nr
    )
    context = {
        "update": update,
        "journal": update.publication.get_journal(),
    }
    return render(request, "journals/publication_update_detail.html", context)


######################
# Feed DOIs to arXiv #
######################


def arxiv_doi_feed(request, doi_label=None):
    """
    This method provides arXiv with the doi and journal ref of the 100 most recent
    publications in the journal specified by doi_label.
    """
    identifier = "SciPost.org arXiv.org DOI feed"

    if doi_label is not None:
        journal = get_object_or_404(Journal, doi_label=doi_label)
        publications = journal.get_publications().order_by("-publication_date")[:100]
        identifier += f" for {doi_label}"
    else:
        publications = Publication.objects.filter(
            status=PUBLICATION_PUBLISHED,
            pubtype=Publication.PUBTYPE_ARTICLE,
            publication_date__gte=timezone.now() - timedelta(days=60),
            # Two months are suggested by arxiv https://info.arxiv.org/help/bib_feed.html
        )

    feedxml = (
        '<preprint xmlns="http://arxiv.org/doi_feed" '
        'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" '
        f'identifier="{identifier}" '
        'version="DOI SnappyFeed v1.0" '
        'xsi:schemaLocation="http://arxiv.org/doi_feed '
        'http://arxiv.org/schemas/doi_feed.xsd">'
    )

    now = timezone.now()
    feedxml += '<date year="%s" month="%s" day="%s" />' % (
        now.strftime("%Y"),
        now.strftime("%m"),
        now.strftime("%d"),
    )
    for publication in publications:
        # Determine if any of the preprints in thread were on arXiv
        for sub in publication.accepted_submission.thread:
            if sub.preprint.is_arXiv:
                feedxml += (
                    '\n<article preprint_id="%s" doi="%s" journal_ref="%s" />'
                    % (
                        sub.preprint.identifier_w_vn_nr.rpartition("v")[0],
                        publication.doi_string,
                        publication.citation,
                    )
                )
                break  # only do once for each publication
    feedxml += "\n</preprint>"
    return HttpResponse(feedxml, content_type="text/xml")
