__copyright__ = "Copyright Â© Stichting SciPost (SciPost Foundation)"
__license__ = "AGPL v3"


from django.contrib import admin, messages
from django import forms

from journals.models import (
    Journal,
    Volume,
    Issue,
    Publication,
    Deposit,
    DOAJDeposit,
    GenericDOIDeposit,
    Reference,
    PublicationAuthorsTable,
    PublicationUpdate,
    SubmissionTemplate,
    AutogeneratedFileContentTemplate,
    PublicationResource,
)

from finances.models import PubFrac
from scipost.models import Contributor
from submissions.models import Submission


class SubmissionTemplateInline(admin.TabularInline):
    model = SubmissionTemplate
    extra = 0


class AutogeneratedFileContentTemplateInline(admin.TabularInline):
    model = AutogeneratedFileContentTemplate
    extra = 0


@admin.register(Journal)
class JournalAdmin(admin.ModelAdmin):
    search_fields = ["name"]
    list_display = ["__str__", "doi_string", "active"]
    inlines = [
        SubmissionTemplateInline,
        AutogeneratedFileContentTemplateInline,
    ]

    # Filter `alternative_journals` to include only ones:
    # - in the same academic field as the current journal
    # - that are active
    def formfield_for_manytomany(self, db_field, request, **kwargs):
        if db_field.name == "alternative_journals":
            journal_id = request.resolver_match.kwargs.get("object_id")

            if journal_id is None:
                return super().formfield_for_manytomany(db_field, request, **kwargs)

            journal = Journal.objects.get(pk=journal_id)
            selections = Journal.objects.filter(name="SciPost Selections")

            # Show all active journals if the current journal is SciPost Selections
            if journal == selections.first():
                kwargs["queryset"] = Journal.objects.all()
            else:
                kwargs["queryset"] = (
                    Journal.objects.filter(college=journal.college) | selections
                )

            kwargs["queryset"] = kwargs["queryset"].active().exclude(pk=journal_id)

        return super().formfield_for_manytomany(db_field, request, **kwargs)


@admin.register(Volume)
class VolumeAdmin(admin.ModelAdmin):
    list_display = ["__str__", "doi_string"]


@admin.register(Issue)
class IssueAdmin(admin.ModelAdmin):
    list_display = ["__str__", "doi_string"]
    search_fields = [
        "in_journal__name",
        "in_volume__in_journal__name",
        "doi_label",
    ]


class ReferenceInline(admin.TabularInline):
    model = Reference
    extra = 0


class AuthorsInline(admin.TabularInline):
    model = PublicationAuthorsTable
    extra = 0
    autocomplete_fields = [
        "profile",
        "affiliations",
    ]


class PublicationResourceInline(admin.TabularInline):
    model = PublicationResource
    extra = 0


class PubFracInline(admin.TabularInline):
    model = PubFrac
    list_display = ("organization", "publication", "fraction")
    autocomplete_fields = [
        "organization",
    ]


@admin.register(Publication)
class PublicationAdmin(admin.ModelAdmin):
    exclude = ["cf_citation", "cf_author_affiliation_indices_list"]
    search_fields = ["title", "author_list", "doi_label"]
    list_display = [
        "title",
        "author_list",
        "in_issue",
        "doi_string",
        "publication_date",
        "status",
    ]
    date_hierarchy = "publication_date"
    list_filter = ["in_issue"]
    inlines = [
        AuthorsInline,
        ReferenceInline,
        PubFracInline,
        PublicationResourceInline,
    ]
    autocomplete_fields = [
        "accepted_submission",
        "grants",
        "funders_generic",
        "topics",
    ]


class PublicationProxyMetadata(Publication):
    search_fields = ["title", "author_list", "doi_label"]
    list_display = [
        "title",
        "author_list",
        "in_issue",
        "doi_string",
        "publication_date",
        "status",
    ]

    class Meta:
        proxy = True
        verbose_name = "Publication metadata"
        verbose_name_plural = "Publication metadata"


@admin.register(PublicationProxyMetadata)
class PublicationProxyMetadataAdmin(admin.ModelAdmin):
    fields = ["metadata", "metadata_xml", "metadata_DOAJ"]
    search_fields = ["title", "author_list", "doi_label"]
    list_display = [
        "title",
        "author_list",
        "in_issue",
        "doi_string",
        "publication_date",
        "status",
    ]


@admin.register(Deposit)
class DepositAdmin(admin.ModelAdmin):
    list_display = (
        "publication",
        "timestamp",
        "doi_batch_id",
        "deposition_date",
    )
    readonly_fields = (
        "publication",
        "doi_batch_id",
        "metadata_xml",
        "deposition_date",
    )
    actions = None

    def message_user(self, request, *args):
        return messages.warning(request, "Sorry, Deposits are readonly.")

    def has_add_permission(self, *args):
        return False

    def has_delete_permission(self, *args):
        return False


@admin.register(DOAJDeposit)
class DOAJDepositAdmin(admin.ModelAdmin):
    autocomplete_fields = [
        "publication",
    ]


admin.site.register(GenericDOIDeposit)


@admin.register(PublicationUpdate)
class PublicationUpdateAdmin(admin.ModelAdmin):
    autocomplete_fields = [
        "publication",
    ]
