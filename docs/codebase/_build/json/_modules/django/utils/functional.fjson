{"customsidebar": null, "body": "<h1>Source code for django.utils.functional</h1><div class=\"highlight\"><pre>\n<span></span><span class=\"kn\">import</span> <span class=\"nn\">copy</span>\n<span class=\"kn\">import</span> <span class=\"nn\">operator</span>\n<span class=\"kn\">import</span> <span class=\"nn\">warnings</span>\n<span class=\"kn\">from</span> <span class=\"nn\">functools</span> <span class=\"k\">import</span> <span class=\"n\">total_ordering</span><span class=\"p\">,</span> <span class=\"n\">wraps</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">django.utils</span> <span class=\"k\">import</span> <span class=\"n\">six</span>\n<span class=\"kn\">from</span> <span class=\"nn\">django.utils.deprecation</span> <span class=\"k\">import</span> <span class=\"n\">RemovedInDjango20Warning</span>\n\n\n<span class=\"c1\"># You can&#39;t trivially replace this with `functools.partial` because this binds</span>\n<span class=\"c1\"># to classes and returns bound instances, whereas functools.partial (on</span>\n<span class=\"c1\"># CPython) is a type and its instances don&#39;t bind.</span>\n<span class=\"k\">def</span> <span class=\"nf\">curry</span><span class=\"p\">(</span><span class=\"n\">_curried_func</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">_curried</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">moreargs</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">morekwargs</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">_curried_func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">args</span> <span class=\"o\">+</span> <span class=\"n\">moreargs</span><span class=\"p\">),</span> <span class=\"o\">**</span><span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">kwargs</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">morekwargs</span><span class=\"p\">))</span>\n    <span class=\"k\">return</span> <span class=\"n\">_curried</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">cached_property</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Decorator that converts a method with a single self argument into a</span>\n<span class=\"sd\">    property cached on the instance.</span>\n\n<span class=\"sd\">    Optional ``name`` argument allows you to make cached properties of other</span>\n<span class=\"sd\">    methods. (e.g.  url = cached_property(get_absolute_url, name=&#39;url&#39;) )</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">func</span> <span class=\"o\">=</span> <span class=\"n\">func</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__doc__</span> <span class=\"o\">=</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"s1\">&#39;__doc__&#39;</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">name</span> <span class=\"ow\">or</span> <span class=\"n\">func</span><span class=\"o\">.</span><span class=\"vm\">__name__</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__get__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">instance</span><span class=\"p\">,</span> <span class=\"bp\">cls</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">instance</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span>\n        <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">instance</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"p\">[</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">name</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">func</span><span class=\"p\">(</span><span class=\"n\">instance</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">res</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">Promise</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    This is just a base class for the proxy class created in</span>\n<span class=\"sd\">    the closure of the lazy function. It can be used to recognize</span>\n<span class=\"sd\">    promises in code.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">pass</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">lazy</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">resultclasses</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Turns any callable into a lazy evaluated callable. You need to give result</span>\n<span class=\"sd\">    classes or types -- at least one is needed so that the automatic forcing of</span>\n<span class=\"sd\">    the lazy evaluation code is triggered. Results are not memoized; the</span>\n<span class=\"sd\">    function is evaluated on every access.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n    <span class=\"nd\">@total_ordering</span>\n    <span class=\"k\">class</span> <span class=\"nc\">__proxy__</span><span class=\"p\">(</span><span class=\"n\">Promise</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">        Encapsulate a function call and act as a proxy for methods that are</span>\n<span class=\"sd\">        called on the result of that function. The function is not evaluated</span>\n<span class=\"sd\">        until one of the methods on the result is called.</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n        <span class=\"n\">__prepared</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"n\">kw</span><span class=\"p\">):</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args</span> <span class=\"o\">=</span> <span class=\"n\">args</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__kw</span> <span class=\"o\">=</span> <span class=\"n\">kw</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__prepared</span><span class=\"p\">:</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__prepare_class__</span><span class=\"p\">()</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__prepared</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">__reduce__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"p\">(</span>\n                <span class=\"n\">_lazy_proxy_unpickle</span><span class=\"p\">,</span>\n                <span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__kw</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">resultclasses</span>\n            <span class=\"p\">)</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">__repr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"nb\">repr</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">())</span>\n\n        <span class=\"nd\">@classmethod</span>\n        <span class=\"k\">def</span> <span class=\"nf\">__prepare_class__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">):</span>\n            <span class=\"k\">for</span> <span class=\"n\">resultclass</span> <span class=\"ow\">in</span> <span class=\"n\">resultclasses</span><span class=\"p\">:</span>\n                <span class=\"k\">for</span> <span class=\"n\">type_</span> <span class=\"ow\">in</span> <span class=\"n\">resultclass</span><span class=\"o\">.</span><span class=\"n\">mro</span><span class=\"p\">():</span>\n                    <span class=\"k\">for</span> <span class=\"n\">method_name</span> <span class=\"ow\">in</span> <span class=\"n\">type_</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">():</span>\n                        <span class=\"c1\"># All __promise__ return the same wrapper method, they</span>\n                        <span class=\"c1\"># look up the correct implementation when called.</span>\n                        <span class=\"k\">if</span> <span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">method_name</span><span class=\"p\">):</span>\n                            <span class=\"k\">continue</span>\n                        <span class=\"n\">meth</span> <span class=\"o\">=</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">__promise__</span><span class=\"p\">(</span><span class=\"n\">method_name</span><span class=\"p\">)</span>\n                        <span class=\"nb\">setattr</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">method_name</span><span class=\"p\">,</span> <span class=\"n\">meth</span><span class=\"p\">)</span>\n            <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">_delegate_bytes</span> <span class=\"o\">=</span> <span class=\"nb\">bytes</span> <span class=\"ow\">in</span> <span class=\"n\">resultclasses</span>\n            <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">_delegate_text</span> <span class=\"o\">=</span> <span class=\"n\">six</span><span class=\"o\">.</span><span class=\"n\">text_type</span> <span class=\"ow\">in</span> <span class=\"n\">resultclasses</span>\n            <span class=\"k\">assert</span> <span class=\"ow\">not</span> <span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">_delegate_bytes</span> <span class=\"ow\">and</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">_delegate_text</span><span class=\"p\">),</span> <span class=\"p\">(</span>\n                <span class=\"s2\">&quot;Cannot call lazy() with both bytes and text return types.&quot;</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">_delegate_text</span><span class=\"p\">:</span>\n                <span class=\"k\">if</span> <span class=\"n\">six</span><span class=\"o\">.</span><span class=\"n\">PY3</span><span class=\"p\">:</span>\n                    <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"fm\">__str__</span> <span class=\"o\">=</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">__text_cast</span>\n                <span class=\"k\">else</span><span class=\"p\">:</span>\n                    <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">__unicode__</span> <span class=\"o\">=</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">__text_cast</span>\n                    <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"fm\">__str__</span> <span class=\"o\">=</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">__bytes_cast_encoded</span>\n            <span class=\"k\">elif</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">_delegate_bytes</span><span class=\"p\">:</span>\n                <span class=\"k\">if</span> <span class=\"n\">six</span><span class=\"o\">.</span><span class=\"n\">PY3</span><span class=\"p\">:</span>\n                    <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"fm\">__bytes__</span> <span class=\"o\">=</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">__bytes_cast</span>\n                <span class=\"k\">else</span><span class=\"p\">:</span>\n                    <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"fm\">__str__</span> <span class=\"o\">=</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">__bytes_cast</span>\n\n        <span class=\"nd\">@classmethod</span>\n        <span class=\"k\">def</span> <span class=\"nf\">__promise__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">method_name</span><span class=\"p\">):</span>\n            <span class=\"c1\"># Builds a wrapper around some magic method</span>\n            <span class=\"k\">def</span> <span class=\"nf\">__wrapper__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kw</span><span class=\"p\">):</span>\n                <span class=\"c1\"># Automatically triggers the evaluation of a lazy value and</span>\n                <span class=\"c1\"># applies the given magic method of the result type.</span>\n                <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__kw</span><span class=\"p\">)</span>\n                <span class=\"k\">return</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">,</span> <span class=\"n\">method_name</span><span class=\"p\">)(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kw</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">__wrapper__</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">__text_cast</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__kw</span><span class=\"p\">)</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">__bytes_cast</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"nb\">bytes</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__kw</span><span class=\"p\">))</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">__bytes_cast_encoded</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__kw</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">encode</span><span class=\"p\">(</span><span class=\"s1\">&#39;utf-8&#39;</span><span class=\"p\">)</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">__cast</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_delegate_bytes</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__bytes_cast</span><span class=\"p\">()</span>\n            <span class=\"k\">elif</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_delegate_text</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__text_cast</span><span class=\"p\">()</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__kw</span><span class=\"p\">)</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">__str__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n            <span class=\"c1\"># object defines __str__(), so __prepare_class__() won&#39;t overload</span>\n            <span class=\"c1\"># a __str__() method from the proxied class.</span>\n            <span class=\"k\">return</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">())</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">__ne__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"p\">,</span> <span class=\"n\">Promise</span><span class=\"p\">):</span>\n                <span class=\"n\">other</span> <span class=\"o\">=</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span> <span class=\"o\">!=</span> <span class=\"n\">other</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">__eq__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"p\">,</span> <span class=\"n\">Promise</span><span class=\"p\">):</span>\n                <span class=\"n\">other</span> <span class=\"o\">=</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"n\">other</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">__lt__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"p\">,</span> <span class=\"n\">Promise</span><span class=\"p\">):</span>\n                <span class=\"n\">other</span> <span class=\"o\">=</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span> <span class=\"o\">&lt;</span> <span class=\"n\">other</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">__hash__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"nb\">hash</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">())</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">__mod__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">rhs</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_delegate_bytes</span> <span class=\"ow\">and</span> <span class=\"n\">six</span><span class=\"o\">.</span><span class=\"n\">PY2</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"nb\">bytes</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"n\">rhs</span>\n            <span class=\"k\">elif</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_delegate_text</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"n\">six</span><span class=\"o\">.</span><span class=\"n\">text_type</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"n\">rhs</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__cast</span><span class=\"p\">()</span> <span class=\"o\">%</span> <span class=\"n\">rhs</span>\n\n        <span class=\"k\">def</span> <span class=\"nf\">__deepcopy__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">memo</span><span class=\"p\">):</span>\n            <span class=\"c1\"># Instances of this class are effectively immutable. It&#39;s just a</span>\n            <span class=\"c1\"># collection of functions. So we don&#39;t need to do anything</span>\n            <span class=\"c1\"># complicated for copying.</span>\n            <span class=\"n\">memo</span><span class=\"p\">[</span><span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span>\n\n    <span class=\"nd\">@wraps</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">)</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__wrapper__</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kw</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Creates the proxy object, instead of the actual value.</span>\n        <span class=\"k\">return</span> <span class=\"n\">__proxy__</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"n\">kw</span><span class=\"p\">)</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">__wrapper__</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_lazy_proxy_unpickle</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"n\">kwargs</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">resultclasses</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">lazy</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">resultclasses</span><span class=\"p\">)(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">lazystr</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Shortcut for the common case of a lazy callable that returns str.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"kn\">from</span> <span class=\"nn\">django.utils.encoding</span> <span class=\"k\">import</span> <span class=\"n\">force_text</span>  <span class=\"c1\"># Avoid circular import</span>\n    <span class=\"k\">return</span> <span class=\"n\">lazy</span><span class=\"p\">(</span><span class=\"n\">force_text</span><span class=\"p\">,</span> <span class=\"n\">six</span><span class=\"o\">.</span><span class=\"n\">text_type</span><span class=\"p\">)(</span><span class=\"n\">text</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">allow_lazy</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">resultclasses</span><span class=\"p\">):</span>\n    <span class=\"n\">warnings</span><span class=\"o\">.</span><span class=\"n\">warn</span><span class=\"p\">(</span>\n        <span class=\"s2\">&quot;django.utils.functional.allow_lazy() is deprecated in favor of &quot;</span>\n        <span class=\"s2\">&quot;django.utils.functional.keep_lazy()&quot;</span><span class=\"p\">,</span>\n        <span class=\"n\">RemovedInDjango20Warning</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">keep_lazy</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">resultclasses</span><span class=\"p\">)(</span><span class=\"n\">func</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">keep_lazy</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">resultclasses</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    A decorator that allows a function to be called with one or more lazy</span>\n<span class=\"sd\">    arguments. If none of the args are lazy, the function is evaluated</span>\n<span class=\"sd\">    immediately, otherwise a __proxy__ is returned that will evaluate the</span>\n<span class=\"sd\">    function when needed.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">resultclasses</span><span class=\"p\">:</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">&quot;You must pass at least one argument to keep_lazy().&quot;</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">decorator</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">):</span>\n        <span class=\"n\">lazy_func</span> <span class=\"o\">=</span> <span class=\"n\">lazy</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">resultclasses</span><span class=\"p\">)</span>\n\n        <span class=\"nd\">@wraps</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">)</span>\n        <span class=\"k\">def</span> <span class=\"nf\">wrapper</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n            <span class=\"k\">for</span> <span class=\"n\">arg</span> <span class=\"ow\">in</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">six</span><span class=\"o\">.</span><span class=\"n\">itervalues</span><span class=\"p\">(</span><span class=\"n\">kwargs</span><span class=\"p\">)):</span>\n                <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">Promise</span><span class=\"p\">):</span>\n                    <span class=\"k\">break</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">lazy_func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">wrapper</span>\n    <span class=\"k\">return</span> <span class=\"n\">decorator</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">keep_lazy_text</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    A decorator for functions that accept lazy arguments and return text.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">return</span> <span class=\"n\">keep_lazy</span><span class=\"p\">(</span><span class=\"n\">six</span><span class=\"o\">.</span><span class=\"n\">text_type</span><span class=\"p\">)(</span><span class=\"n\">func</span><span class=\"p\">)</span>\n\n\n<span class=\"n\">empty</span> <span class=\"o\">=</span> <span class=\"nb\">object</span><span class=\"p\">()</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">new_method_proxy</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">inner</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span> <span class=\"ow\">is</span> <span class=\"n\">empty</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_setup</span><span class=\"p\">()</span>\n        <span class=\"k\">return</span> <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">inner</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">LazyObject</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    A wrapper for another class that can be used to delay instantiation of the</span>\n<span class=\"sd\">    wrapped class.</span>\n\n<span class=\"sd\">    By subclassing, you have the opportunity to intercept and alter the</span>\n<span class=\"sd\">    instantiation. If you don&#39;t need to do that, use SimpleLazyObject.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n    <span class=\"c1\"># Avoid infinite recursion when tracing __init__ (#19456).</span>\n    <span class=\"n\">_wrapped</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Note: if a subclass overrides __init__(), it will likely need to</span>\n        <span class=\"c1\"># override __copy__() and __deepcopy__() as well.</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span> <span class=\"o\">=</span> <span class=\"n\">empty</span>\n\n    <span class=\"fm\">__getattr__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"nb\">getattr</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__setattr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s2\">&quot;_wrapped&quot;</span><span class=\"p\">:</span>\n            <span class=\"c1\"># Assign to __dict__ to avoid infinite __setattr__ loops.</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"p\">[</span><span class=\"s2\">&quot;_wrapped&quot;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">value</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span> <span class=\"ow\">is</span> <span class=\"n\">empty</span><span class=\"p\">:</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_setup</span><span class=\"p\">()</span>\n            <span class=\"nb\">setattr</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__delattr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s2\">&quot;_wrapped&quot;</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">&quot;can&#39;t delete _wrapped.&quot;</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span> <span class=\"ow\">is</span> <span class=\"n\">empty</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_setup</span><span class=\"p\">()</span>\n        <span class=\"nb\">delattr</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_setup</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">        Must be implemented by subclasses to initialize the wrapped object.</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">NotImplementedError</span><span class=\"p\">(</span><span class=\"s1\">&#39;subclasses of LazyObject must provide a _setup() method&#39;</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Because we have messed with __class__ below, we confuse pickle as to what</span>\n    <span class=\"c1\"># class we are pickling. We&#39;re going to have to initialize the wrapped</span>\n    <span class=\"c1\"># object to successfully pickle it, so we might as well just pickle the</span>\n    <span class=\"c1\"># wrapped object since they&#39;re supposed to act the same way.</span>\n    <span class=\"c1\">#</span>\n    <span class=\"c1\"># Unfortunately, if we try to simply act like the wrapped object, the ruse</span>\n    <span class=\"c1\"># will break down when pickle gets our id(). Thus we end up with pickle</span>\n    <span class=\"c1\"># thinking, in effect, that we are a distinct object from the wrapped</span>\n    <span class=\"c1\"># object, but with the same __dict__. This can cause problems (see #25389).</span>\n    <span class=\"c1\">#</span>\n    <span class=\"c1\"># So instead, we define our own __reduce__ method and custom unpickler. We</span>\n    <span class=\"c1\"># pickle the wrapped object as the unpickler&#39;s argument, so that pickle</span>\n    <span class=\"c1\"># will pickle it normally, and then the unpickler simply returns its</span>\n    <span class=\"c1\"># argument.</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__reduce__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span> <span class=\"ow\">is</span> <span class=\"n\">empty</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_setup</span><span class=\"p\">()</span>\n        <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">unpickle_lazyobject</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span><span class=\"p\">,))</span>\n\n    <span class=\"c1\"># Overriding __class__ stops __reduce__ from being called on Python 2.</span>\n    <span class=\"c1\"># So, define __getstate__ in a way that cooperates with the way that</span>\n    <span class=\"c1\"># pickle interprets this class. This fails when the wrapped class is a</span>\n    <span class=\"c1\"># builtin, but it&#39;s better than nothing.</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__getstate__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span> <span class=\"ow\">is</span> <span class=\"n\">empty</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_setup</span><span class=\"p\">()</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__copy__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span> <span class=\"ow\">is</span> <span class=\"n\">empty</span><span class=\"p\">:</span>\n            <span class=\"c1\"># If uninitialized, copy the wrapper. Use type(self), not</span>\n            <span class=\"c1\"># self.__class__, because the latter is proxied.</span>\n            <span class=\"k\">return</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)()</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"c1\"># If initialized, return a copy of the wrapped object.</span>\n            <span class=\"k\">return</span> <span class=\"n\">copy</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__deepcopy__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">memo</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span> <span class=\"ow\">is</span> <span class=\"n\">empty</span><span class=\"p\">:</span>\n            <span class=\"c1\"># We have to use type(self), not self.__class__, because the</span>\n            <span class=\"c1\"># latter is proxied.</span>\n            <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)()</span>\n            <span class=\"n\">memo</span><span class=\"p\">[</span><span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)]</span> <span class=\"o\">=</span> <span class=\"n\">result</span>\n            <span class=\"k\">return</span> <span class=\"n\">result</span>\n        <span class=\"k\">return</span> <span class=\"n\">copy</span><span class=\"o\">.</span><span class=\"n\">deepcopy</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span><span class=\"p\">,</span> <span class=\"n\">memo</span><span class=\"p\">)</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">six</span><span class=\"o\">.</span><span class=\"n\">PY3</span><span class=\"p\">:</span>\n        <span class=\"fm\">__bytes__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"nb\">bytes</span><span class=\"p\">)</span>\n        <span class=\"fm\">__str__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">)</span>\n        <span class=\"fm\">__bool__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"nb\">bool</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"fm\">__str__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">)</span>\n        <span class=\"n\">__unicode__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"n\">unicode</span><span class=\"p\">)</span>  <span class=\"c1\"># NOQA: unicode undefined on PY3</span>\n        <span class=\"n\">__nonzero__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"nb\">bool</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Introspection support</span>\n    <span class=\"fm\">__dir__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"nb\">dir</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Need to pretend to be the wrapped class, for the sake of objects that</span>\n    <span class=\"c1\"># care about this (especially in equality tests)</span>\n    <span class=\"vm\">__class__</span> <span class=\"o\">=</span> <span class=\"nb\">property</span><span class=\"p\">(</span><span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"o\">.</span><span class=\"n\">attrgetter</span><span class=\"p\">(</span><span class=\"s2\">&quot;__class__&quot;</span><span class=\"p\">)))</span>\n    <span class=\"fm\">__eq__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"o\">.</span><span class=\"n\">eq</span><span class=\"p\">)</span>\n    <span class=\"fm\">__ne__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"o\">.</span><span class=\"n\">ne</span><span class=\"p\">)</span>\n    <span class=\"fm\">__hash__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"nb\">hash</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># List/Tuple/Dictionary methods support</span>\n    <span class=\"fm\">__getitem__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"o\">.</span><span class=\"n\">getitem</span><span class=\"p\">)</span>\n    <span class=\"fm\">__setitem__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"o\">.</span><span class=\"n\">setitem</span><span class=\"p\">)</span>\n    <span class=\"fm\">__delitem__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"o\">.</span><span class=\"n\">delitem</span><span class=\"p\">)</span>\n    <span class=\"fm\">__iter__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"nb\">iter</span><span class=\"p\">)</span>\n    <span class=\"fm\">__len__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">)</span>\n    <span class=\"fm\">__contains__</span> <span class=\"o\">=</span> <span class=\"n\">new_method_proxy</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"o\">.</span><span class=\"n\">contains</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">unpickle_lazyobject</span><span class=\"p\">(</span><span class=\"n\">wrapped</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Used to unpickle lazy objects. Just return its argument, which will be the</span>\n<span class=\"sd\">    wrapped object.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">return</span> <span class=\"n\">wrapped</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">SimpleLazyObject</span><span class=\"p\">(</span><span class=\"n\">LazyObject</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    A lazy object initialized from any function.</span>\n\n<span class=\"sd\">    Designed for compound objects of unknown type. For builtins or objects of</span>\n<span class=\"sd\">    known type, use django.utils.functional.lazy.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">func</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">        Pass in a callable that returns the object to be wrapped.</span>\n\n<span class=\"sd\">        If copies are made of the resulting SimpleLazyObject, which can happen</span>\n<span class=\"sd\">        in various circumstances within Django, then you must ensure that the</span>\n<span class=\"sd\">        callable can be safely run more than once and will return the same</span>\n<span class=\"sd\">        value.</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"p\">[</span><span class=\"s1\">&#39;_setupfunc&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">func</span>\n        <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">SimpleLazyObject</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">()</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_setup</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_setupfunc</span><span class=\"p\">()</span>\n\n    <span class=\"c1\"># Return a meaningful representation of the lazy object for debugging</span>\n    <span class=\"c1\"># without evaluating the wrapped object.</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__repr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span> <span class=\"ow\">is</span> <span class=\"n\">empty</span><span class=\"p\">:</span>\n            <span class=\"n\">repr_attr</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_setupfunc</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">repr_attr</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span>\n        <span class=\"k\">return</span> <span class=\"s1\">&#39;&lt;</span><span class=\"si\">%s</span><span class=\"s1\">: </span><span class=\"si\">%r</span><span class=\"s1\">&gt;&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"vm\">__name__</span><span class=\"p\">,</span> <span class=\"n\">repr_attr</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__copy__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span> <span class=\"ow\">is</span> <span class=\"n\">empty</span><span class=\"p\">:</span>\n            <span class=\"c1\"># If uninitialized, copy the wrapper. Use SimpleLazyObject, not</span>\n            <span class=\"c1\"># self.__class__, because the latter is proxied.</span>\n            <span class=\"k\">return</span> <span class=\"n\">SimpleLazyObject</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_setupfunc</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"c1\"># If initialized, return a copy of the wrapped object.</span>\n            <span class=\"k\">return</span> <span class=\"n\">copy</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__deepcopy__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">memo</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span> <span class=\"ow\">is</span> <span class=\"n\">empty</span><span class=\"p\">:</span>\n            <span class=\"c1\"># We have to use SimpleLazyObject, not self.__class__, because the</span>\n            <span class=\"c1\"># latter is proxied.</span>\n            <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">SimpleLazyObject</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_setupfunc</span><span class=\"p\">)</span>\n            <span class=\"n\">memo</span><span class=\"p\">[</span><span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)]</span> <span class=\"o\">=</span> <span class=\"n\">result</span>\n            <span class=\"k\">return</span> <span class=\"n\">result</span>\n        <span class=\"k\">return</span> <span class=\"n\">copy</span><span class=\"o\">.</span><span class=\"n\">deepcopy</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_wrapped</span><span class=\"p\">,</span> <span class=\"n\">memo</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">partition</span><span class=\"p\">(</span><span class=\"n\">predicate</span><span class=\"p\">,</span> <span class=\"n\">values</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Splits the values into two sets, based on the return value of the function</span>\n<span class=\"sd\">    (True/False). e.g.:</span>\n\n<span class=\"sd\">        &gt;&gt;&gt; partition(lambda x: x &gt; 3, range(5))</span>\n<span class=\"sd\">        [0, 1, 2, 3], [4]</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"p\">([],</span> <span class=\"p\">[])</span>\n    <span class=\"k\">for</span> <span class=\"n\">item</span> <span class=\"ow\">in</span> <span class=\"n\">values</span><span class=\"p\">:</span>\n        <span class=\"n\">results</span><span class=\"p\">[</span><span class=\"n\">predicate</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">)]</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">results</span>\n</pre></div>", "parents": [{"link": "../../../", "title": "Module code"}], "current_page_name": "_modules/django/utils/functional", "title": "django.utils.functional", "alabaster_version": "0.7.10", "sidebars": null}